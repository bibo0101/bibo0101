it('should remove the risk item from the specified risk level', () => {
  const riskItems = new Map();
  riskItems.set('High', [{ name: 'Risk A' }, { name: 'Risk B' }]);

  const updatedRiskItems = removeRiskItem('High', 'Risk A', riskItems);

  expect(updatedRiskItems.get('High')).toHaveLength(1);
  expect(updatedRiskItems.get('High')[0].name).toBe('Risk B');
});
it('should create a new RiskItem with the correct properties', () => {
  const riskName = 'Risk A';
  const riskType = 'Boolean';
  const riskItem = newRiskItem(riskName, riskType);

  expect(riskItem.name).toBe(riskName);
  expect(riskItem.type).toBe(riskType);
});
it('should generate the correct label for boolean risks', () => {
  const label = booleanRiskLabel('Risk A');
  expect(label).toBe('Boolean risk: Risk A');
});

================================================
import {
    addRiskItem,
    removeRiskItem,
    riskItemsListIncludes,
    riskItemsIndexOfRiskName,
    newRiskItem,
    countryOrIndustryRiskLabel,
    booleanRiskLabel,
} from './path/to/your/riskFunctions'; // Adjust the import based on your structure
import { RiskItem, RiskLabel, RiskLevel, RiskName, RiskType } from 'src/interfaces/RiskInterfaces';

describe('Risk Functions', () => {
    const riskLevel: RiskLevel = 'High'; // Example risk level
    const riskName: RiskName = 'Risk A'; // Example risk name
    const riskType: RiskType = 'boolean'; // Example risk type
    const riskItems: Map<RiskLevel, RiskItem[]> = new Map();

    describe('addRiskItem', () => {
        it('should add a new RiskItem to the specified risk level', () => {
            const updatedRiskItems = addRiskItem(riskLevel, riskName, riskType, riskItems);
            expect(updatedRiskItems.get(riskLevel)).toHaveLength(1);
            expect(updatedRiskItems.get(riskLevel)[0].riskName).toBe(riskName);
        });

        it('should add multiple RiskItems to the same risk level', () => {
            addRiskItem(riskLevel, riskName, riskType, riskItems);
            addRiskItem(riskLevel, 'Risk B', 'boolean', riskItems);
            const updatedRiskItems = addRiskItem(riskLevel, 'Risk C', 'boolean', riskItems);
            expect(updatedRiskItems.get(riskLevel)).toHaveLength(3);
        });
    });

    describe('removeRiskItem', () => {
        it('should remove a RiskItem from the specified risk level', () => {
            addRiskItem(riskLevel, riskName, riskType, riskItems);
            const updatedRiskItems = removeRiskItem(riskLevel, riskName, riskItems);
            expect(updatedRiskItems.get(riskLevel)).toHaveLength(0);
        });

        it('should not change the risk items if the RiskItem does not exist', () => {
            addRiskItem(riskLevel, riskName, riskType, riskItems);
            const updatedRiskItems = removeRiskItem(riskLevel, 'Non-existent Risk', riskItems);
            expect(updatedRiskItems.get(riskLevel)).toHaveLength(1);
        });

        it('should remove the risk level if no RiskItems remain', () => {
            addRiskItem(riskLevel, riskName, riskType, riskItems);
            const updatedRiskItems = removeRiskItem(riskLevel, riskName, riskItems);
            expect(updatedRiskItems.has(riskLevel)).toBe(false);
        });
    });

    describe('riskItemsListIncludes', () => {
        it('should return true if the risk name exists in the list', () => {
            const riskItem: RiskItem = newRiskItem(riskName, riskType);
            const riskItemsList: RiskItem[] = [riskItem];
            const result = riskItemsListIncludes(riskName, riskItemsList);
            expect(result).toBe(true);
        });

        it('should return false if the risk name does not exist in the list', () => {
            const riskItemsList: RiskItem[] = [];
            const result = riskItemsListIncludes(riskName, riskItemsList);
            expect(result).toBe(false);
        });

        it('should return false if the risk items list is undefined', () => {
            const result = riskItemsListIncludes(riskName, undefined);
            expect(result).toBe(false);
        });
    });

    describe('riskItemsIndexOfRiskName', () => {
        it('should return the index of the risk item by its name', () => {
            const riskItem: RiskItem = newRiskItem(riskName, riskType);
            const riskItemsList: RiskItem[] = [riskItem];
            const index = riskItemsIndexOfRiskName(riskName, riskItemsList);
            expect(index).toBe(0);
        });

        it('should return -1 if the risk item does not exist', () => {
            const riskItemsList: RiskItem[] = [];
            const index = riskItemsIndexOfRiskName(riskName, riskItemsList);
            expect(index).toBe(-1);
        });
    });

    describe('newRiskItem', () => {
        it('should create a new RiskItem with the correct properties', () => {
            const riskItem = newRiskItem(riskName, riskType);
            expect(riskItem.riskName).toBe(riskName);
            expect(riskItem.riskType).toBe(riskType);
            expect(riskItem.riskLabel).toBe('Boolean risk: Risk A'); // Adjust based on the risk type
        });
    });

    describe('countryOrIndustryRiskLabel', () => {
        it('should generate the correct label for country or industry risks', () => {
            const label = countryOrIndustryRiskLabel(riskName);
            expect(label).toBe('Please explain connection(s) to Risk A');
        });
    });

    describe('booleanRiskLabel', () => {
        it('should generate the correct label for boolean risks', () => {
            const label = booleanRiskLabel(riskName);
            expect(label).toBe('Boolean risk: Risk A');
        });
    });
});

=================================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { useSelector } from 'react-redux';
import CloneConfirmationModal from './CloneConfirmationModal'; // Adjust the path as necessary
import '@testing-library/jest-dom/extend-expect';

jest.mock('react-redux', () => ({
  useSelector: jest.fn(),
}));

describe('CloneConfirmationModal', () => {
  it('renders loading state when loading is true', () => {
    render(
      <CloneConfirmationModal
        modelReference={jest.fn()}
        modalClose={jest.fn()}
        cloneEntity={null}
        cloneFcrmData={jest.fn()}
        loading={true}
        error={null}
      />
    );

    expect(screen.getByRole('img', { name: /loading/i })).toBeInTheDocument();
  });

  it('renders error icon when there is an error', () => {
    render(
      <CloneConfirmationModal
        modelReference={jest.fn()}
        modalClose={jest.fn()}
        cloneEntity={null}
        cloneFcrmData={jest.fn()}
        loading={false}
        error="Some error occurred"
      />
    );

    expect(screen.getByRole('img', { name: /document/i })).toHaveAttribute('status', 'error');
  });

  it('renders success icon when FCRM status is "Completed"', () => {
    (useSelector as jest.Mock).mockReturnValue('Completed');

    render(
      <CloneConfirmationModal
        modelReference={jest.fn()}
        modalClose={jest.fn()}
        cloneEntity={null}
        cloneFcrmData={jest.fn()}
        loading={false}
        error={null}
      />
    );

    expect(screen.getByRole('img', { name: /document/i })).toHaveAttribute('status', 'success');
  });

  it('calls modalClose when "No" button is clicked', () => {
    const modalCloseMock = jest.fn();

    render(
      <CloneConfirmationModal
        modelReference={jest.fn()}
        modalClose={modalCloseMock}
        cloneEntity={null}
        cloneFcrmData={jest.fn()}
        loading={false}
        error={null}
      />
    );

    const noButton = screen.getByRole('button', { name: /no/i });
    fireEvent.click(noButton);

    expect(modalCloseMock).toHaveBeenCalledTimes(1);
  });

  it('calls cloneFcrmData when "Yes" button is clicked', () => {
    const cloneFcrmDataMock = jest.fn();

    render(
      <CloneConfirmationModal
        modelReference={jest.fn()}
        modalClose={jest.fn()}
        cloneEntity={{ partyName: 'Test Party' }}
        cloneFcrmData={cloneFcrmDataMock}
        loading={false}
        error={null}
      />
    );

    const yesButton = screen.getByRole('button', { name: /yes/i });
    fireEvent.click(yesButton);

    expect(cloneFcrmDataMock).toHaveBeenCalledTimes(1);
  });

  it('displays FCRM not completed message', () => {
    (useSelector as jest.Mock).mockReturnValue('In Progress');

    render(
      <CloneConfirmationModal
        modelReference={jest.fn()}
        modalClose={jest.fn()}
        cloneEntity={null}
        cloneFcrmData={jest.fn()}
        loading={false}
        error={null}
      />
    );

    expect(screen.getByText(/fcrm is not completed/i)).toBeInTheDocument();
  });

  it('displays party name in modal content', () => {
    render(
      <CloneConfirmationModal
        modelReference={jest.fn()}
        modalClose={jest.fn()}
        cloneEntity={{ partyName: 'Test Party' }}
        cloneFcrmData={jest.fn()}
        loading={false}
        error={null}
      />
    );

    expect(screen.getByText(/do you want to clone fcrm for Test Party/i)).toBeInTheDocument();
  });
});

==================================================================
it('renders AttestationPanel without crashing', () => {
  render(<AttestationPanel readOnly={false} />);
  expect(screen.getByText('Attestation')).toBeInTheDocument();
});

-----------------------------------------------------------------AttestationPanel test cases
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import AttestationPanel from './AttestationPanel'; // Adjust the import path as necessary
import { updateFcrmAttestation } from '../../../redux/slices/fcrmAttestationSlice';
import { getUser Info } from '../../helpers/userDetails';
import { useApiProvider } from '../../../Fcrm/hooks/useApiProvider';

// Mock the necessary functions and modules
jest.mock('../../../redux/slices/fcrmAttestationSlice', () => ({
    updateFcrmAttestation: jest.fn(),
}));

jest.mock('../../helpers/userDetails', () => ({
    getUser Info: jest.fn(),
}));

const mockStore = configureStore([]);

describe('AttestationPanel Component', () => {
    let store;

    beforeEach(() => {
        store = mockStore({
            riskScore: {
                baseRiskScore: 100,
                overriddenRiskScore: 80,
            },
            attestationData: {
                attestedByName: '',
                attestedByBrid: '',
            },
            // Add other necessary initial state here
        });
    });

    it('renders correctly when readOnly is true', () => {
        render(
            <Provider store={store}>
                <AttestationPanel readOnly={true} />
            </Provider>
        );

        expect(screen.getByText(/Attestation/i)).toBeInTheDocument();
        expect(screen.getByText(/You requested a Risk Rating change from:/i)).toBeInTheDocument();
        expect(screen.getByText(/Risk Rating for party is:/i)).toBeInTheDocument();
    });

    it('renders correctly when readOnly is false', () => {
        render(
            <Provider store={store}>
                <AttestationPanel readOnly={false} />
            </Provider>
        );

        expect(screen.getByText(/Attestation/i)).toBeInTheDocument();
        // Add more assertions based on what should be rendered when not readOnly
    });

    it('dispatches updateFcrmAttestation when setAttestation is called', () => {
        const { getByTestId } = render(
            <Provider store={store}>
                <AttestationPanel readOnly={false} />
            </Provider>
        );

        // Simulate a user action that triggers setAttestation
        fireEvent.click(getByTestId('attest-button')); // Adjust the test ID as necessary

        expect(updateFcrmAttestation).toHaveBeenCalled();
    });

    it('dispatches updateFcrmAttestation with user data when setOverrideAttestation is called', () => {
        const userData = { userName: 'John Doe', userBrid: '12345' };
        (getUser Info as jest.Mock).mockReturnValue(userData);

        const { getByTestId } = render(
            <Provider store={store}>
                <AttestationPanel readOnly={false} />
            </Provider>
        );

        // Simulate a user action that triggers setOverrideAttestation
        fireEvent.click(getByTestId('override-button')); // Adjust the test ID as necessary

        expect(updateFcrmAttestation).toHaveBeenCalledWith(expect.objectContaining({
            attestedByName: 'John Doe',
            attestedByBrid: '12345',
        }));
    });

    // Add more tests as necessary to cover other functionalities
});
======================================
it('should remove the risk name if it is overridden and exists at index 0', () => {
        const riskItem: RiskItem = { riskName: 'Risk A', overridden: true };
        const overriddenRisks: QuestionId[] = ['Risk A', 'Risk B'];

        const updatedRisks = updateOverrideItems(riskItem, overriddenRisks);
        expect(updatedRisks).toEqual(['Risk B']); // 'Risk A' should be removed
    });

    it('should remove the risk name if it is overridden and exists at index 1', () => {
        const riskItem: RiskItem = { riskName: 'Risk B', overridden: true };
        const overriddenRisks: QuestionId[] = ['Risk A', 'Risk B'];

        const updatedRisks = updateOverrideItems(riskItem, overriddenRisks);
        expect(updatedRisks).toEqual(['Risk A']); // 'Risk B' should be removed
    });
================================================================================
import { updateRiskItemArray, updateOverrideItems } from './path/to/your/riskFunctions'; // Adjust the import based on your structure
import { RiskItem, QuestionId } from 'src/interfaces/RiskInterfaces';

describe('Risk Functions', () => {
    describe('updateRiskItemArray', () => {
        it('should update the risk item in the array if it exists', () => {
            const riskItem: RiskItem = { riskName: 'Risk A', overridden: true };
            const riskItemArray: RiskItem[] = [
                { riskName: 'Risk A', overridden: false },
                { riskName: 'Risk B', overridden: false },
            ];

            const updatedArray = updateRiskItemArray(riskItem, riskItemArray);
            expect(updatedArray).toEqual([
                { riskName: 'Risk A', overridden: true }, // Updated
                { riskName: 'Risk B', overridden: false },
            ]);
        });

        it('should not change the array if the risk item does not exist', () => {
            const riskItem: RiskItem = { riskName: 'Risk C', overridden: true };
            const riskItemArray: RiskItem[] = [
                { riskName: 'Risk A', overridden: false },
                { riskName: 'Risk B', overridden: false },
            ];

            const updatedArray = updateRiskItemArray(riskItem, riskItemArray);
            expect(updatedArray).toEqual(riskItemArray); // No change
        });

        it('should handle an empty array', () => {
            const riskItem: RiskItem = { riskName: 'Risk A', overridden: true };
            const riskItemArray: RiskItem[] = [];

            const updatedArray = updateRiskItemArray(riskItem, riskItemArray);
            expect(updatedArray).toEqual([]); // Still empty
        });
    });

    describe('updateOverrideItems', () => {
        it('should remove the risk name if it is overridden', () => {
            const riskItem: RiskItem = { riskName: 'Risk A', overridden: true };
            const overriddenRisks: QuestionId[] = ['Risk A', 'Risk B'];

            const updatedRisks = updateOverrideItems(riskItem, overriddenRisks);
            expect(updatedRisks).toEqual(['Risk B']); // 'Risk A' should be removed
        });

        it('should add the risk name if it is not already in the list and is overridden', () => {
            const riskItem: RiskItem = { riskName: 'Risk C', overridden: true };
            const overriddenRisks: QuestionId[] = ['Risk A', 'Risk B'];

            const updatedRisks = updateOverrideItems(riskItem, overriddenRisks);
            expect(updatedRisks

it('should not change the overridden risks if the risk item is not overridden', () => {
            const riskItem: RiskItem = { riskName: 'Risk A', overridden: false };
            const overriddenRisks: QuestionId[] = ['Risk A', 'Risk B'];

            const updatedRisks = updateOverrideItems(riskItem, overriddenRisks);
            expect(updatedRisks).toEqual(['Risk A', 'Risk B']); // No change
        });

        it('should not change the overridden risks if the risk item is not found and is overridden', () => {
            const riskItem: RiskItem = { riskName: 'Risk C', overridden: true };
            const overriddenRisks: QuestionId[] = ['Risk A', 'Risk B'];

            const updatedRisks = updateOverrideItems(riskItem, overriddenRisks);
            expect(updatedRisks).toEqual(['Risk A', 'Risk B', 'Risk C']); // 'Risk C' should be added
        });

        it('should handle an empty overridden risks array', () => {
            const riskItem: RiskItem = { riskName: 'Risk A', overridden: true };
            const overriddenRisks: QuestionId[] = [];

            const updatedRisks = updateOverrideItems(riskItem, overriddenRisks);
            expect(updatedRisks).toEqual(['Risk A']); // 'Risk A' should be added
        });
    });
=================================================================
import { updateOverrideItems } from "./path-to-your-functions";
import { RiskItem, QuestionId } from "src/interfaces/RiskInterfaces";

describe("updateOverrideItems", () => {
  it("should add the riskName to overriddenRisks if overridden is true", () => {
    const riskItem: RiskItem = { riskName: "Risk1", overridden: true };
    const overriddenRisks: QuestionId[] = ["Risk2"];

    const updatedRisks = updateOverrideItems(riskItem, overriddenRisks);

    expect(updatedRisks).toEqual(["Risk2", "Risk1"]);
  });

  it("should remove the riskName from overriddenRisks if overridden is false", () => {
    const riskItem: RiskItem = { riskName: "Risk1", overridden: false };
    const overriddenRisks: QuestionId[] = ["Risk1", "Risk2"];

    const updatedRisks = updateOverrideItems(riskItem, overriddenRisks);

    expect(updatedRisks).toEqual(["Risk2"]);
  });

  it("should not modify the overriddenRisks if riskName is not present and overridden is false", () => {
    const riskItem: RiskItem = { riskName: "Risk3", overridden: false };
    const overriddenRisks: QuestionId[] = ["Risk1", "Risk2"];

    const updatedRisks = updateOverrideItems(riskItem, overriddenRisks);

    expect(updatedRisks).toEqual(["Risk1", "Risk2"]);
  });

  it("should handle an empty overriddenRisks array and add riskName if overridden is true", () => {
    const riskItem: RiskItem = { riskName: "Risk1", overridden: true };
    const overriddenRisks: QuestionId[] = [];

    const updatedRisks = updateOverrideItems(riskItem, overriddenRisks);

    expect(updatedRisks).toEqual(["Risk1"]);
  });
});

===========================================

describe('getUserInfo', () => {
  beforeEach(() => {
    // Clear sessionStorage before each test
    sessionStorage.clear();
  });

  it('should throw an error if user information is missing in sessionStorage', () => {
    expect(() => getUserInfo()).toThrow('Unable to find user information');
  });

  it('should throw an error if user information is incomplete', () => {
    const incompleteUserInfo = JSON.stringify({ firstName: '', lastName: '', guId: null });
    sessionStorage.setItem('userInfo', incompleteUserInfo);

    expect(() => getUserInfo()).toThrow('Missing user information');
  });

  it('should return user information when all fields are valid', () => {
    const validUserInfo = JSON.stringify({ firstName: 'John', lastName: 'Doe', guId: '12345' });
    sessionStorage.setItem('userInfo', validUserInfo);

    const result = getUserInfo();
    expect(result).toEqual({ userName: 'John Doe', userBrid: '12345' });
  });
});

============================================================
import { getUser Info } from './path/to/your/getUser Info'; // Adjust the import based on your structure
import { loggedInUser  } from '../../interfaces/ApiInterfaces';

describe('getUser Info', () => {
    beforeEach(() => {
        // Clear session storage before each test
        sessionStorage.clear();
    });

    it('should return user information when valid data is present in session storage', () => {
        const mockUser  = {
            firstName: 'John',
            lastName: 'Doe',
            guId: '12345',
        };

        // Set mock user data in session storage
        sessionStorage.setItem('userInfo', JSON.stringify(mockUser ));

        const expectedUser Info: loggedInUser  = {
            userName: 'John Doe',
            userBrid: '12345',
        };

        // Call the function and check the result
        const userInfo = getUser Info();
        expect(userInfo).toEqual(expectedUser Info);
    });

    it('should throw an error if user information is not found in session storage', () => {
        expect(() => getUser Info()).toThrow('Unable to find user information');
    });

    it('should throw an error if user information is incomplete', () => {
        const incompleteUser  = {
            firstName: 'Jane',
            lastName: '', // Missing last name
            guId: '67890',
        };

        // Set incomplete user data in session storage
        sessionStorage.setItem('userInfo', JSON.stringify(incompleteUser ));

        expect(() => getUser Info()).toThrow('Missing user information');
    });

    it('should throw an error if user information is missing fields', () => {
        const incompleteUser  = {
            firstName: 'Jane',
            // lastName is missing
            guId: '67890',
        };

        // Set incomplete user data in session storage
        sessionStorage.setItem('userInfo', JSON.stringify(incompleteUser ));

        expect(() => getUser Info()).toThrow('Missing user information');
    });
});
==================================================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import RiskScoreContainer from './RiskScoreContainer';
import { RiskScoreDisplay } from '../../../Generic/RiskScoreDisplay/RiskScoreDisplay'; // Adjust the import based on your structure
import { getRiskRating } from 'src/redux/selectors/riskDataSelectors'; // Adjust the import based on your structure

const mockStore = configureStore([]);

describe('RiskScoreContainer Component', () => {
    let store;

    beforeEach(() => {
        store = mockStore({
            riskScore: {
                overriddenRiskScore: 'High', // Example risk score
            },
        });
    });

    it('renders the RiskScoreDisplay with the correct risk rating', () => {
        render(
            <Provider store={store}>
                <RiskScoreContainer />
            </Provider>
        );

        // Check if the RiskScoreDisplay is rendered with the correct risk rating
        expect(screen.getByText(/Risk Attestation/i)).toBeInTheDocument();
        expect(screen.getByText(/High/i)).toBeInTheDocument(); // Check for the risk rating
    });

    it('renders an empty RiskScoreDisplay when overriddenRiskScore is not set', () => {
        store = mockStore({
            riskScore: {
                overriddenRiskScore: '', // No risk score
            },
        });

        render(
            <Provider store={store}>
                <RiskScoreContainer />
            </Provider>
        );

        // Check if the RiskScoreDisplay is rendered with an empty risk rating
        expect(screen.getByText(/Risk Attestation/i)).toBeInTheDocument();
        expect(screen.queryByText(/High/i)).not.toBeInTheDocument(); // Ensure 'High' is not present
        expect(screen.getByText(/''/i)).not.toBeInTheDocument(); // Adjust based on how you handle empty states
    });
});
=====================================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import RiskScoreContainer from './RiskScoreContainer';
import { RiskScoreDisplay } from './RiskScoreDisplay'; // Adjust the import based on your structure

const mockStore = configureStore([]);

describe('RiskScoreContainer Component', () => {
    let store;

    beforeEach(() => {
        store = mockStore({
            riskScore: {
                overriddenRiskScore: 'High', // Example risk score
            },
        });
    });

    it('renders the RiskScoreDisplay with the correct risk rating', () => {
        render(
            <Provider store={store}>
                <RiskScoreContainer />
            </Provider>
        );

        // Check if the RiskScoreDisplay is rendered with the correct risk rating
        expect(screen.getByText(/High/i)).toBeInTheDocument();
    });

    it('renders an empty RiskScoreDisplay when overriddenRiskScore is not set', () => {
        store = mockStore({
            riskScore: {
                overriddenRiskScore: '', // No risk score
            },
        });

        render(
            <Provider store={store}>
                <RiskScoreContainer />
            </Provider>
        );

        // Check if the RiskScoreDisplay is rendered with an empty risk rating
        expect(screen.getByText(/''/i)).not.toBeInTheDocument(); // Adjust based on how you handle empty states
    });
});

=================================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import ReviewAndAttest from './ReviewAndAttest';
import { useApiProvider } from './../../../hooks/useApiProvider';

// Mock the useApiProvider hook
jest.mock('./../../../hooks/useApiProvider', () => ({
    useApiProvider: jest.fn(),
}));

describe('ReviewAndAttest Component', () => {
    it('renders the Review & Attest button', () => {
        // Mock the apiProvider return value
        const mockReviewAndAttestData = jest.fn();
        useApiProvider.mockReturnValue({ reviewAndAttestData: mockReviewAndAttestData });

        render(<ReviewAndAttest />);

        // Check if the button is in the document
        const buttonElement = screen.getByText(/Review & Attest/i);
        expect(buttonElement).toBeInTheDocument();

        // Optionally, check if the button click calls the mock function
        buttonElement.click();
        expect(mockReviewAndAttestData).toHaveBeenCalled();
    });
});
------------------------------------------------------------------
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import ReviewAndAttest from './ReviewAndAttest';
import { useApiProvider } from './../../../hooks/useApiProvider';

// Mock the `useApiProvider` hook
jest.mock('./../../../hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(),
}));

describe('ReviewAndAttest Component', () => {
  const mockReviewAndAttestData = jest.fn();

  beforeEach(() => {
    (useApiProvider as jest.Mock).mockReturnValue({
      reviewAndAttestData: mockReviewAndAttestData,
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('renders the Panel component correctly', () => {
    render(<ReviewAndAttest />);
    const panel = screen.getByTestId('panel');
    expect(panel).toBeInTheDocument();
    expect(panel).toHaveStyle({ marginBottom: '0.75em' });
  });

  test('renders the Button with the correct props', () => {
    render(<ReviewAndAttest />);
    const button = screen.getByRole('button', { name: /review & attest/i });

    expect(button).toBeInTheDocument();
    expect(button).toHaveAttribute('variant', 'primary');
    expect(button).toHaveAttribute('mediaPosition', 'right');
  });

  test('renders the Icon inside the Button', () => {
    render(<ReviewAndAttest />);
    const icon = screen.getByTestId('icon'); // If your Icon component uses a `data-testid`
    expect(icon).toBeInTheDocument();
    expect(icon).toHaveAttribute('icon', 'document');
    expect(icon).toHaveAttribute('size', 'sm');
  });

  test('calls reviewAndAttestData on Button click', () => {
    render(<ReviewAndAttest />);
    const button = screen.getByRole('button', { name: /review & attest/i });

    fireEvent.click(button);

    // Verify the function was called
    expect(mockReviewAndAttestData).toHaveBeenCalledTimes(1);
  });
});

====================================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom'; // For additional matchers like 'toBeInTheDocument'
import ReviewAndAttest from './ReviewAndAttest';
import { useApiProvider } from './../../../hooks/useApiProvider';

// Mock the `useApiProvider` hook
jest.mock('./../../../hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(),
}));

describe('ReviewAndAttest Component', () => {
  const mockReviewAndAttestData = jest.fn();

  beforeEach(() => {
    (useApiProvider as jest.Mock).mockReturnValue({
      reviewAndAttestData: mockReviewAndAttestData,
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('renders the component correctly', () => {
    render(<ReviewAndAttest />);

    // Assert that the button is in the document
    const button = screen.getByRole('button', { name: /review & attest/i });
    expect(button).toBeInTheDocument();

    // Assert that the icon is rendered
    const icon = screen.getByTestId('icon'); // Assuming Icon has a `data-testid` or equivalent
    expect(icon).toBeInTheDocument();
  });

  test('button click calls the reviewAndAttestData function', () => {
    render(<ReviewAndAttest />);

    const button = screen.getByRole('button', { name: /review & attest/i });
    fireEvent.click(button);

    // Assert that the API function was called
    expect(mockReviewAndAttestData).toHaveBeenCalledTimes(1);
  });

  test('button has correct styling and properties', () => {
    render(<ReviewAndAttest />);

    const button = screen.getByRole('button', { name: /review & attest/i });

    // Assert button has the correct classes or attributes
    expect(button).toHaveClass('bp3-button'); // Adjust for Blueprint class
    expect(button).toHaveAttribute('variant', 'primary');
    expect(button).toHaveAttribute('mediaPosition', 'right');
  });
});

=======================================================================
<button
  data-testid="alert-dismiss-button"
  onClick={() => contentProvider?.updateFcrmAlerts(undefined)}
>
  Dismiss
</button>

=======================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    const dismissButton = screen.getByText('Dismiss');
    fireEvent.click(dismissButton);

    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  // Additional tests for completeness
  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });

  it('handles missing updateFcrmAlerts function gracefully', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: null,
    });

    render(<Alerts />);

    const dismissButton = screen.getByText('Dismiss');
    fireEvent.click(dismissButton);

    // No error should be thrown, but there's no function to call
    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
  });

  it('renders without crashing when useContentProvider fails', () => {
    useContentProvider.mockImplementation(() => {
      throw new Error('Failed to fetch content provider');
    });

    expect(() => render(<Alerts />)).not.toThrow();
  });

  it('renders default message when status is unknown', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'unknown',
        message: 'Unknown status!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Unknown:')).toBeInTheDocument();
    expect(screen.getByText('Unknown status!')).toBeInTheDocument();
  });

  it('has correct ARIA attributes for accessibility', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
    expect(screen.getByRole('alert')).toHaveAttribute('aria-live', 'assertive');
  });
});
=================================================================================

onDismiss={() => {
  console.log('onDismiss called'); // Debug log
  contentProvider?.updateFcrmAlerts(undefined);
}}



it('does not throw error if updateFcrmAlerts is not defined', () => {
  useContentProvider.mockReturnValue({
    fcrmAlert: {
      status: 'success',
      message: 'Operation successful',
    },
  });

  render(<Alerts />);
  const dismissButton = screen.getByRole('button', { name: /dismiss/i });

  // Simulate dismiss action
  expect(() => fireEvent.click(dismissButton)).not.toThrow();
});


it('matches snapshot for success state', () => {
  useContentProvider.mockReturnValue({
    fcrmAlert: {
      status: 'success',
      message: 'Operation successful',
    },
  });

  const { asFragment } = render(<Alerts />);
  expect(asFragment()).toMatchSnapshot();
});


======================================================
it('does not render Alert when contentProvider is null', () => {
  useContentProvider.mockReturnValue(null);

  const { container } = render(<Alerts />);
  expect(container.firstChild).toBeNull();
});

=============================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    const dismissButton = screen.getByRole('button', { name: /dismiss/i });
    fireEvent.click(dismissButton);

    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });
});

=============================================================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    fireEvent.click(screen.getByRole('button', { name: /dismiss/i }));
    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });
});



===================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts';
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });
});

======================================================================================================

import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts';
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
  });

  it('renders error status and message', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
  });
});
===============================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import Alerts from './alert'; // Adjust the import path as needed
import { useContentProvider } from '../../hooks/useContentProvider';

// Mock the `useContentProvider` hook
jest.mock('../../hooks/useContentProvider', () => ({
  useContentProvider: jest.fn(),
}));

describe('Alerts Component', () => {
  it('renders the Alert with success status and message', () => {
    // Mock data for the content provider
    const mockContentProvider = {
      fcrmAlert: {
        status: 'success',
        message: 'Operation completed successfully.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Check if the Alert is rendered with success status
    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation completed successfully.')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders the Alert with error status and message', () => {
    const mockContentProvider = {
      fcrmAlert: {
        status: 'error',
        message: 'There was an error processing your request.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Check if the Alert is rendered with error status
    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('There was an error processing your request.')).toBeInTheDocument();
  });

  it('calls onDismiss when the Alert is dismissed', () => {
    const mockContentProvider = {
      fcrmAlert: {
        status: 'success',
        message: 'Operation completed successfully.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Simulate the dismiss action
    const dismissButton = screen.getByRole('button');
    fireEvent.click(dismissButton);

    // Verify that `updateFcrmAlerts` was called
    expect(mockContentProvider.updateFcrmAlerts).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if fcrmAlert is undefined', () => {
    const mockContentProvider = {
      fcrmAlert: undefined,
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    const { container } = render(<Alerts />);

    // Check that nothing is rendered
    expect(container.firstChild).toBeNull();
  });
});

=========================================================================================
jest.mock('@barclays/clm-react-document', () => ({
  ...jest.requireActual('@barclays/clm-react-document'), // Include other actual exports
  ClmReactDocumentUploader: jest.fn((props) => (
    <div data-testid="mock-document-uploader">
      Mock Document Uploader
      <button onClick={props.onFilesUpload}>Upload Files</button>
    </div>
  )),
}));

jest.mock('./CLMUploadDocDetails', () => jest.fn(() => <div data-testid="mock-upload-details">Mock Upload Details</div>));
jest.mock('../../../Fcrm/hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(() => ({
    someMethod: jest.fn(),
  })),
}));
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import YourComponent from './YourComponent';

test('renders mock components correctly', () => {
  render(<YourComponent />);

  // Verify that the mocked `ClmReactDocumentUploader` is rendered
  expect(screen.getByTestId('mock-document-uploader')).toBeInTheDocument();

  // Verify that the mocked `CLMUploadDocDetails` is rendered
  expect(screen.getByTestId('mock-upload-details')).toBeInTheDocument();
});

test('calls onFilesUpload when upload button is clicked', () => {
  const onFilesUpload = jest.fn();

  render(
    <YourComponent
      ClmReactDocumentUploader={{
        onFilesUpload,
      }}
    />
  );

  const uploadButton = screen.getByText('Upload Files');
  fireEvent.click(uploadButton);

  expect(onFilesUpload).toHaveBeenCalledTimes(1);
});

====================================================================

jest.mock('@barclays/clm-react-docum', () => ({
  ClmReactDocumentUploader: jest.fn(() => <div>Mock Uploader</div>),
}));

jest.mock('./CLMUploadDocDetails', () => jest.fn(() => <div>Mock Upload Details</div>));

=====================================================================
const nxPreset = require("@nx/jest/preset");

module.exports = {
  ...nxPreset,
  testEnvironment: "jest-environment-jsdom",
  transform: {
    "^.+\\.[tj]sx?$": "babel-jest",
  },
};
=====================================================================
import React from "react";

const MyComponent: React.FC = () => {
  return <div>Hello, Jest!</div>;
};

export default MyComponent;

=====================================================================
import React from "react";
import { render, screen } from "@testing-library/react";
import MyComponent from "./MyComponent";

describe("MyComponent", () => {
  it("renders correctly", () => {
    render(<MyComponent />);
    expect(screen.getByText("Hello, Jest!")).toBeInTheDocument();
  });
});

================================================================================

npm install --save @nx/react react react-dom
npm install --save-dev @babel/core babel-jest @babel/preset-env @babel/preset-react @babel/preset-typescript jest ts-jest typescript

npm install --save-dev babel-jest @babel/core @babel/preset-env @babel/preset-react
npm install --save-dev @babel/preset-typescript
========================================================

import React from 'react';
import { render, fireEvent } from '@testing-library/react';
import { CLMSelect } from './CLMSelect';

describe('CLMSelect Component', () => {
  it('should render the options and call handleChange on selection', () => {
    // Manual mock function
    const mockHandleChange = (fieldName: string, value: any) => {
      console.log(`handleChange called with fieldName: ${fieldName}, value: ${value}`);
    };

    const mockConfig = {
      fieldName: 'selectField',
      fieldLabel: 'Select Option',
      fieldDescription: 'Choose an option',
      values: ['Option 1', 'Option 2', 'Option 3'],
    };

    const { getByLabelText, getByRole } = render(
      <CLMSelect
        componentConfig={mockConfig}
        section="test-section"
        handleChange={mockHandleChange}
        value="Option 1"
        readOnly={false}
      />
    );

    // Check if options are rendered
    expect(getByRole('option', { name: 'Option 1' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 2' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 3' })).toBeInTheDocument();

    // Simulate user selecting a new option
    fireEvent.change(getByLabelText('Select Option'), { target: { value: 'Option 2' } });

    // Output will be visible in the console
  });
});

===========================================================================
import React from 'react';
import { render, fireEvent } from '@testing-library/react';
import { CLMSelect } from './CLMSelect';

describe('CLMSelect Component', () => {
  it('should render the options and call handleChange on selection', () => {
    const mockHandleChange = jest.fn();

    const mockConfig = {
      fieldName: 'selectField',
      fieldLabel: 'Select Option',
      fieldDescription: 'Choose an option',
      values: ['Option 1', 'Option 2', 'Option 3'],
    };

    const { getByLabelText, getByRole } = render(
      <CLMSelect
        componentConfig={mockConfig}
        section="test-section"
        handleChange={mockHandleChange}
        value="Option 1"
        readOnly={false}
      />
    );

    // Check if options are rendered
    expect(getByRole('option', { name: 'Option 1' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 2' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 3' })).toBeInTheDocument();

    // Simulate user selecting a new option
    fireEvent.change(getByLabelText('Select Option'), { target: { value: 'Option 2' } });

    // Check if handleChange was called
    expect(mockHandleChange).toHaveBeenCalledWith('selectField', 'Option 2');
  });
});

=======================================================================================
{
  "name": "<your-project-name>",
  "targets": {
    "test": {
      "executor": "@nrwl/jest:jest",
      "options": {
        "jestConfig": "apps/<your-project-name>/jest.config.ts",
        "passWithNoTests": true
      },
      "outputs": ["coverage/apps/<your-project-name>"]
    }
  }
}

==========================================
const nxPreset = require('@nx/jest/preset').default;

module.exports = { ...nxPreset };

===============================================================

import { getJestProjects } from '@nx/jest';

export default {
  displayName: '<your-project-name>',
  preset: '../../jest.preset.js',
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
  globals: {},
  transform: {
    '^.+\\.[tj]sx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],
  coverageDirectory: '../../coverage/apps/<your-project-name>',
  testEnvironment: 'jsdom', // Use 'node' if not React-based
};

===============================================================


===============================================================
{
  "projects": {
    "clm-ui-fcrm": {
      "root": "apps/clm-ui-fcrm",
      "sourceRoot": "apps/clm-ui-fcrm/src",
      "projectType": "application",
      "targets": {
        "test": {
          "executor": "@nrwl/jest:jest",
          "outputs": ["coverage/apps/clm-ui-fcrm"],
          "options": {
            "jestConfig": "apps/clm-ui-fcrm/jest.config.ts",
            "passWithNoTests": true
          }
        }
      }
    }
  }
}

=========================================================================
import { Config } from '@jest/types';

// Sync object
const config: Config.InitialOptions = {
  setupFilesAfterEnv: ['./jest.setup.ts'], // Reference the setup file
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.tsx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
};

export default config;
=======================

import React from "react";
import { render, screen } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with the correct path to your component

// Default props for the test
const defaultProps = {
  componentConfig: {
    fieldName: "testDate",
    fieldLabel: "Test Date",
    description: "Select a date",
  },
  section: "Test Section",
  handleChange: jest.fn(),
  value: "2025-01-01",
  errorMessage: "",
  readOnly: false,
};

describe("CLMDate Component", () => {
  it("renders the label and input field", () => {
    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Assert: Check if the label is displayed
    expect(screen.getByText("Test Date")).toBeInTheDocument();

    // Assert: Check if the input field with the correct value is rendered
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeInTheDocument();
    expect(input).toHaveAttribute("type", "date");
  });
});




import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import CLMDate from './CLMDate'; // Adjust the import path based on your project structure

jest.mock('@barclays/blueprint-react', () => ({
  __esModule: true,  // This line indicates that the module is an ES module
  ...jest.requireActual('@barclays/blueprint-react'),
  Icon: () => <span>MockIcon</span>,  // Mock the Icon component
}));

const visibilityRule = { linkedFieldName: 'someField', linkedFieldValue: true };

const componentConfig = {
  fieldName: 'date',
  fieldLabel: 'Date',
  componentType: 'input',
  description: 'Select a date',
  values: ['2025-01-16'],
  isVisible: visibilityRule,
  isEditable: true,
  validation: 'required'
};

test('renders CLMDate component', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  const inputElement = screen.getByLabelText('Date');
  expect(inputElement).toBeInTheDocument();
});

test('calls handleChange on input change', () => {
  const handleChange = jest.fn();
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={handleChange} readOnly={false} />);
  const inputElement = screen.getByLabelText('Date');
  fireEvent.change(inputElement, { target: { value: '2025-01-16' } });
  expect(handleChange).toHaveBeenCalledWith('date', '2025-01-16');
});

test('displays error message', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} errorMessage="Invalid date" />);
  const errorElement = screen.getByText('Invalid date');
  expect(errorElement).toBeInTheDocument();
});

test('renders component as editable or read-only based on isEditable property', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  const editableInputElement = screen.getByLabelText('Date');
  expect(editableInputElement).not.toBeDisabled();

  const readOnlyConfig = { ...componentConfig, isEditable: false };
  render(<CLMDate componentConfig={readOnlyConfig} value="" handleChange={() => {}} readOnly={true} />);
  const readOnlyInputElement = screen.getByLabelText('Date');
  expect(readOnlyInputElement).toBeDisabled();
});

=============================================================================
jest.mock('@barclays/blueprint-react', () => {
  const originalModule = jest.requireActual('@barclays/blueprint-react');
  return {
    ...originalModule,
    Icon: ({ icon }) => <span data-testid={`icon-${icon}`}>{icon}</span>, // Mock icon rendering
  };
});

===========================================================================
{
  "targets": {
    "test": {
      "executor": "@nrwl/jest:jest",
      "options": {
        "jestConfig": "apps/your-app/jest.config.ts",
        "passWithNoTests": true
      },
      "outputs": ["coverage/apps/your-app"]
    }
  }
}
==================================================================
nx generate @nrwl/jest:configuration your-app-or-lib-name

==================================================================
import { getJestProjects } from '@nrwl/jest';

export default {
  projects: getJestProjects(),
};
===================================================================
/* jest.config.ts */
export default {
  displayName: 'your-app',
  preset: '../../jest.preset.js',
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.[tj]sx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],
  coverageDirectory: '../../coverage/apps/your-app',
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
};
==================================================================
import '@testing-library/jest-dom';

==================================================================
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with your actual file path
import { ICLMDate } from "./CLMDate.types"; // Replace with your actual interface path

describe("CLMDate Component", () => {
  const mockHandleChange = jest.fn();

  const defaultProps: ICLMDate = {
    componentConfig: {
      fieldName: "testDate",
      fieldLabel: "Test Date",
      description: "Select a date",
    },
    handleChange: mockHandleChange,
    value: "2025-01-01",
    errorMessage: "",
    readOnly: false,
  };

  it("renders the component correctly", () => {
    render(<CLMDate {...defaultProps} />);

    // Check if label is rendered
    expect(screen.getByText("Test Date")).toBeInTheDocument();
    // Check if description is rendered
    expect(screen.getByText("Select a date")).toBeInTheDocument();
    // Check if input is rendered
    const input = screen.getByRole("textbox");
    expect(input).toBeInTheDocument();
    expect(input).toHaveValue("2025-01-01");
  });

  it("calls handleChange when input value changes", () => {
    render(<CLMDate {...defaultProps} />);

    const input = screen.getByRole("textbox");
    fireEvent.change(input, { target: { value: "2025-02-01" } });

    expect(mockHandleChange).toHaveBeenCalledTimes(1);
    expect(mockHandleChange).toHaveBeenCalledWith("testDate", "2025-02-01");
  });

  it("displays an error message if provided", () => {
    render(
      <CLMDate
        {...defaultProps}
        errorMessage="This field is required"
      />
    );

    // Check if the error message is displayed
    expect(screen.getByText("This field is required")).toBeInTheDocument();
  });

  it("disables the input when readOnly is true", () => {
    render(
      <CLMDate
        {...defaultProps}
        readOnly={true}
      />
    );

    const input = screen.getByRole("textbox");
    expect(input).toBeDisabled();
  });

  it("renders the calendar icon", () => {
    render(<CLMDate {...defaultProps} />);

    const calendarIcon = screen.getByLabelText("calendar");
    expect(calendarIcon).toBeInTheDocument();
  });

  it("renders without crashing when section prop is provided", () => {
    render(<CLMDate {...defaultProps} section="Test Section" />);

    // Check if component renders properly with the section prop
    expect(screen.getByText("Test Date")).toBeInTheDocument();
  });
});
=================================================================================================
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with the correct file path
import { ICLMdate } from "./CLMDate.types"; // Replace with the correct file path

const defaultProps: ICLMdate = {
  componentConfig: {
    fieldName: "testDate",
    fieldLabel: "Test Date",
    description: "Select a date",
  },
  section: "General",
  handleChange: jest.fn(),
  value: "2025-01-01",
  errorMessage: "",
  readOnly: false,
};

describe("CLMDate Component", () => {
  it("renders the component with label, description, and input field", () => {
    render(<CLMDate {...defaultProps} />);

    // Check the label
    expect(screen.getByText("Test Date")).toBeInTheDocument();

    // Check the description
    expect(screen.getByText("Select a date")).toBeInTheDocument();

    // Check the input field
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeInTheDocument();
    expect(input).toHaveAttribute("type", "date");
  });

  it("calls handleChange when the input value changes", () => {
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const input = screen.getByDisplayValue("2025-01-01");

    // Simulate changing the input value
    fireEvent.change(input, { target: { value: "2025-02-01" } });

    // Check if handleChange was called with the correct arguments
    expect(defaultProps.handleChange).toHaveBeenCalledWith(
      "testDate",
      "2025-02-01"
    );
  });

  it("displays an error message when errorMessage prop is provided", () => {
    const propsWithError = {
      ...defaultProps,
      errorMessage: "Invalid date",
    };

    render(<CLMDate {...propsWithError} />);

    // Check if the error message is displayed
    expect(screen.getByText("Invalid date")).toBeInTheDocument();
  });

  it("renders a disabled input when readOnly is true", () => {
    const readOnlyProps = {
      ...defaultProps,
      readOnly: true,
    };

    render(<CLMDate {...readOnlyProps} />);

    // Check if the input is disabled
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeDisabled();
  });
});
===========================================================================================
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import { CLMDate } from './CLMDate';
import { ICLMdate } from './CLMDate.types';

describe('CLMDate Component', () => {
  it('should render the CLMDate component correctly', () => {
    // Mock handleChange function
    const mockHandleChange = jest.fn();

    // Default props for the component
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: mockHandleChange,
      value: '2024-01-01',
      errorMessage: '',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find elements in the component
    const inputElement = screen.getByRole('textbox');
    const labelElement = screen.getByText('Test Label');
    const descriptionElement = screen.getByText('Test Description');

    // Assertions: Input field, label, and description should be present
    expect(inputElement).toBeInTheDocument();
    expect(labelElement).toBeInTheDocument();
    expect(descriptionElement).toBeInTheDocument();

    // Assert input attributes
    expect(inputElement).toHaveAttribute('type', 'date');
    expect(inputElement).toHaveAttribute('value', '2024-01-01');
    expect(inputElement).not.toBeDisabled();
  });

  it('should call handleChange when input value changes', () => {
    // Mock handleChange function
    const mockHandleChange = jest.fn();

    // Default props
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: mockHandleChange,
      value: '2024-01-01',
      errorMessage: '',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const inputElement = screen.getByRole('textbox');

    // Simulate a change event
    fireEvent.change(inputElement, { target: { value: '2024-02-01' } });

    // Assert handleChange was called with correct arguments
    expect(mockHandleChange).toHaveBeenCalledWith('testField', '2024-02-01');
  });

  it('should render an error message if provided', () => {
    // Default props with an error message
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: jest.fn(),
      value: '2024-01-01',
      errorMessage: 'Invalid date',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the error message
    const errorElement = screen.getByText('Invalid date');

    // Assert the error message is rendered
    expect(errorElement).toBeInTheDocument();
  });

  it('should disable the input field if readOnly is true', () => {
    // Default props with readOnly set to true
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: jest.fn(),
      value: '2024-01-01',
      errorMessage: '',
      readOnly: true,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const inputElement = screen.getByRole('textbox');

    // Assert the input field is disabled
    expect(inputElement).toBeDisabled();
  });
})
=================================================================================
test('renders CLMDate component', () => {
  const componentConfig = { fieldName: 'date', fieldLabel: 'Date', description: 'Select a date' };
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  
  const inputElement = screen.getByLabelText('Date');
  expect(inputElement).toBeInTheDocument();
});



----------------------------------------------------------------
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import ReviewAndAttest from './ReviewAndAttest';
import { useApiProvider } from './../../../hooks/useApiProvider';

// Mock the `useApiProvider` hook
jest.mock('./../../../hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(),
}));

describe('ReviewAndAttest Component', () => {
  const mockReviewAndAttestData = jest.fn();

  beforeEach(() => {
    (useApiProvider as jest.Mock).mockReturnValue({
      reviewAndAttestData: mockReviewAndAttestData,
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('renders the Panel component correctly', () => {
    render(<ReviewAndAttest />);
    const panel = screen.getByTestId('panel');
    expect(panel).toBeInTheDocument();
    expect(panel).toHaveStyle({ marginBottom: '0.75em' });
  });

  test('renders the Button with the correct props', () => {
    render(<ReviewAndAttest />);
    const button = screen.getByRole('button', { name: /review & attest/i });

    expect(button).toBeInTheDocument();
    expect(button).toHaveAttribute('variant', 'primary');
    expect(button).toHaveAttribute('mediaPosition', 'right');
  });

  test('renders the Icon inside the Button', () => {
    render(<ReviewAndAttest />);
    const icon = screen.getByTestId('icon'); // If your Icon component uses a `data-testid`
    expect(icon).toBeInTheDocument();
    expect(icon).toHaveAttribute('icon', 'document');
    expect(icon).toHaveAttribute('size', 'sm');
  });

  test('calls reviewAndAttestData on Button click', () => {
    render(<ReviewAndAttest />);
    const button = screen.getByRole('button', { name: /review & attest/i });

    fireEvent.click(button);

    // Verify the function was called
    expect(mockReviewAndAttestData).toHaveBeenCalledTimes(1);
  });
});

====================================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom'; // For additional matchers like 'toBeInTheDocument'
import ReviewAndAttest from './ReviewAndAttest';
import { useApiProvider } from './../../../hooks/useApiProvider';

// Mock the `useApiProvider` hook
jest.mock('./../../../hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(),
}));

describe('ReviewAndAttest Component', () => {
  const mockReviewAndAttestData = jest.fn();

  beforeEach(() => {
    (useApiProvider as jest.Mock).mockReturnValue({
      reviewAndAttestData: mockReviewAndAttestData,
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('renders the component correctly', () => {
    render(<ReviewAndAttest />);

    // Assert that the button is in the document
    const button = screen.getByRole('button', { name: /review & attest/i });
    expect(button).toBeInTheDocument();

    // Assert that the icon is rendered
    const icon = screen.getByTestId('icon'); // Assuming Icon has a `data-testid` or equivalent
    expect(icon).toBeInTheDocument();
  });

  test('button click calls the reviewAndAttestData function', () => {
    render(<ReviewAndAttest />);

    const button = screen.getByRole('button', { name: /review & attest/i });
    fireEvent.click(button);

    // Assert that the API function was called
    expect(mockReviewAndAttestData).toHaveBeenCalledTimes(1);
  });

  test('button has correct styling and properties', () => {
    render(<ReviewAndAttest />);

    const button = screen.getByRole('button', { name: /review & attest/i });

    // Assert button has the correct classes or attributes
    expect(button).toHaveClass('bp3-button'); // Adjust for Blueprint class
    expect(button).toHaveAttribute('variant', 'primary');
    expect(button).toHaveAttribute('mediaPosition', 'right');
  });
});

=======================================================================
<button
  data-testid="alert-dismiss-button"
  onClick={() => contentProvider?.updateFcrmAlerts(undefined)}
>
  Dismiss
</button>

=======================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    const dismissButton = screen.getByText('Dismiss');
    fireEvent.click(dismissButton);

    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  // Additional tests for completeness
  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });

  it('handles missing updateFcrmAlerts function gracefully', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: null,
    });

    render(<Alerts />);

    const dismissButton = screen.getByText('Dismiss');
    fireEvent.click(dismissButton);

    // No error should be thrown, but there's no function to call
    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
  });

  it('renders without crashing when useContentProvider fails', () => {
    useContentProvider.mockImplementation(() => {
      throw new Error('Failed to fetch content provider');
    });

    expect(() => render(<Alerts />)).not.toThrow();
  });

  it('renders default message when status is unknown', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'unknown',
        message: 'Unknown status!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Unknown:')).toBeInTheDocument();
    expect(screen.getByText('Unknown status!')).toBeInTheDocument();
  });

  it('has correct ARIA attributes for accessibility', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
    expect(screen.getByRole('alert')).toHaveAttribute('aria-live', 'assertive');
  });
});
=================================================================================

onDismiss={() => {
  console.log('onDismiss called'); // Debug log
  contentProvider?.updateFcrmAlerts(undefined);
}}



it('does not throw error if updateFcrmAlerts is not defined', () => {
  useContentProvider.mockReturnValue({
    fcrmAlert: {
      status: 'success',
      message: 'Operation successful',
    },
  });

  render(<Alerts />);
  const dismissButton = screen.getByRole('button', { name: /dismiss/i });

  // Simulate dismiss action
  expect(() => fireEvent.click(dismissButton)).not.toThrow();
});


it('matches snapshot for success state', () => {
  useContentProvider.mockReturnValue({
    fcrmAlert: {
      status: 'success',
      message: 'Operation successful',
    },
  });

  const { asFragment } = render(<Alerts />);
  expect(asFragment()).toMatchSnapshot();
});


======================================================
it('does not render Alert when contentProvider is null', () => {
  useContentProvider.mockReturnValue(null);

  const { container } = render(<Alerts />);
  expect(container.firstChild).toBeNull();
});

=============================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    const dismissButton = screen.getByRole('button', { name: /dismiss/i });
    fireEvent.click(dismissButton);

    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });
});

=============================================================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    fireEvent.click(screen.getByRole('button', { name: /dismiss/i }));
    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });
});



===================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts';
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });
});

======================================================================================================

import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts';
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
  });

  it('renders error status and message', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
  });
});
===============================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import Alerts from './alert'; // Adjust the import path as needed
import { useContentProvider } from '../../hooks/useContentProvider';

// Mock the `useContentProvider` hook
jest.mock('../../hooks/useContentProvider', () => ({
  useContentProvider: jest.fn(),
}));

describe('Alerts Component', () => {
  it('renders the Alert with success status and message', () => {
    // Mock data for the content provider
    const mockContentProvider = {
      fcrmAlert: {
        status: 'success',
        message: 'Operation completed successfully.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Check if the Alert is rendered with success status
    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation completed successfully.')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders the Alert with error status and message', () => {
    const mockContentProvider = {
      fcrmAlert: {
        status: 'error',
        message: 'There was an error processing your request.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Check if the Alert is rendered with error status
    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('There was an error processing your request.')).toBeInTheDocument();
  });

  it('calls onDismiss when the Alert is dismissed', () => {
    const mockContentProvider = {
      fcrmAlert: {
        status: 'success',
        message: 'Operation completed successfully.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Simulate the dismiss action
    const dismissButton = screen.getByRole('button');
    fireEvent.click(dismissButton);

    // Verify that `updateFcrmAlerts` was called
    expect(mockContentProvider.updateFcrmAlerts).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if fcrmAlert is undefined', () => {
    const mockContentProvider = {
      fcrmAlert: undefined,
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    const { container } = render(<Alerts />);

    // Check that nothing is rendered
    expect(container.firstChild).toBeNull();
  });
});

=========================================================================================
jest.mock('@barclays/clm-react-document', () => ({
  ...jest.requireActual('@barclays/clm-react-document'), // Include other actual exports
  ClmReactDocumentUploader: jest.fn((props) => (
    <div data-testid="mock-document-uploader">
      Mock Document Uploader
      <button onClick={props.onFilesUpload}>Upload Files</button>
    </div>
  )),
}));

jest.mock('./CLMUploadDocDetails', () => jest.fn(() => <div data-testid="mock-upload-details">Mock Upload Details</div>));
jest.mock('../../../Fcrm/hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(() => ({
    someMethod: jest.fn(),
  })),
}));
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import YourComponent from './YourComponent';

test('renders mock components correctly', () => {
  render(<YourComponent />);

  // Verify that the mocked `ClmReactDocumentUploader` is rendered
  expect(screen.getByTestId('mock-document-uploader')).toBeInTheDocument();

  // Verify that the mocked `CLMUploadDocDetails` is rendered
  expect(screen.getByTestId('mock-upload-details')).toBeInTheDocument();
});

test('calls onFilesUpload when upload button is clicked', () => {
  const onFilesUpload = jest.fn();

  render(
    <YourComponent
      ClmReactDocumentUploader={{
        onFilesUpload,
      }}
    />
  );

  const uploadButton = screen.getByText('Upload Files');
  fireEvent.click(uploadButton);

  expect(onFilesUpload).toHaveBeenCalledTimes(1);
});

====================================================================

jest.mock('@barclays/clm-react-docum', () => ({
  ClmReactDocumentUploader: jest.fn(() => <div>Mock Uploader</div>),
}));

jest.mock('./CLMUploadDocDetails', () => jest.fn(() => <div>Mock Upload Details</div>));

=====================================================================
const nxPreset = require("@nx/jest/preset");

module.exports = {
  ...nxPreset,
  testEnvironment: "jest-environment-jsdom",
  transform: {
    "^.+\\.[tj]sx?$": "babel-jest",
  },
};
=====================================================================
import React from "react";

const MyComponent: React.FC = () => {
  return <div>Hello, Jest!</div>;
};

export default MyComponent;

=====================================================================
import React from "react";
import { render, screen } from "@testing-library/react";
import MyComponent from "./MyComponent";

describe("MyComponent", () => {
  it("renders correctly", () => {
    render(<MyComponent />);
    expect(screen.getByText("Hello, Jest!")).toBeInTheDocument();
  });
});

================================================================================

npm install --save @nx/react react react-dom
npm install --save-dev @babel/core babel-jest @babel/preset-env @babel/preset-react @babel/preset-typescript jest ts-jest typescript

npm install --save-dev babel-jest @babel/core @babel/preset-env @babel/preset-react
npm install --save-dev @babel/preset-typescript
========================================================

import React from 'react';
import { render, fireEvent } from '@testing-library/react';
import { CLMSelect } from './CLMSelect';

describe('CLMSelect Component', () => {
  it('should render the options and call handleChange on selection', () => {
    // Manual mock function
    const mockHandleChange = (fieldName: string, value: any) => {
      console.log(`handleChange called with fieldName: ${fieldName}, value: ${value}`);
    };

    const mockConfig = {
      fieldName: 'selectField',
      fieldLabel: 'Select Option',
      fieldDescription: 'Choose an option',
      values: ['Option 1', 'Option 2', 'Option 3'],
    };

    const { getByLabelText, getByRole } = render(
      <CLMSelect
        componentConfig={mockConfig}
        section="test-section"
        handleChange={mockHandleChange}
        value="Option 1"
        readOnly={false}
      />
    );

    // Check if options are rendered
    expect(getByRole('option', { name: 'Option 1' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 2' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 3' })).toBeInTheDocument();

    // Simulate user selecting a new option
    fireEvent.change(getByLabelText('Select Option'), { target: { value: 'Option 2' } });

    // Output will be visible in the console
  });
});

===========================================================================
import React from 'react';
import { render, fireEvent } from '@testing-library/react';
import { CLMSelect } from './CLMSelect';

describe('CLMSelect Component', () => {
  it('should render the options and call handleChange on selection', () => {
    const mockHandleChange = jest.fn();

    const mockConfig = {
      fieldName: 'selectField',
      fieldLabel: 'Select Option',
      fieldDescription: 'Choose an option',
      values: ['Option 1', 'Option 2', 'Option 3'],
    };

    const { getByLabelText, getByRole } = render(
      <CLMSelect
        componentConfig={mockConfig}
        section="test-section"
        handleChange={mockHandleChange}
        value="Option 1"
        readOnly={false}
      />
    );

    // Check if options are rendered
    expect(getByRole('option', { name: 'Option 1' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 2' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 3' })).toBeInTheDocument();

    // Simulate user selecting a new option
    fireEvent.change(getByLabelText('Select Option'), { target: { value: 'Option 2' } });

    // Check if handleChange was called
    expect(mockHandleChange).toHaveBeenCalledWith('selectField', 'Option 2');
  });
});

=======================================================================================
{
  "name": "<your-project-name>",
  "targets": {
    "test": {
      "executor": "@nrwl/jest:jest",
      "options": {
        "jestConfig": "apps/<your-project-name>/jest.config.ts",
        "passWithNoTests": true
      },
      "outputs": ["coverage/apps/<your-project-name>"]
    }
  }
}

==========================================
const nxPreset = require('@nx/jest/preset').default;

module.exports = { ...nxPreset };

===============================================================

import { getJestProjects } from '@nx/jest';

export default {
  displayName: '<your-project-name>',
  preset: '../../jest.preset.js',
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
  globals: {},
  transform: {
    '^.+\\.[tj]sx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],
  coverageDirectory: '../../coverage/apps/<your-project-name>',
  testEnvironment: 'jsdom', // Use 'node' if not React-based
};

===============================================================


===============================================================
{
  "projects": {
    "clm-ui-fcrm": {
      "root": "apps/clm-ui-fcrm",
      "sourceRoot": "apps/clm-ui-fcrm/src",
      "projectType": "application",
      "targets": {
        "test": {
          "executor": "@nrwl/jest:jest",
          "outputs": ["coverage/apps/clm-ui-fcrm"],
          "options": {
            "jestConfig": "apps/clm-ui-fcrm/jest.config.ts",
            "passWithNoTests": true
          }
        }
      }
    }
  }
}

=========================================================================
import { Config } from '@jest/types';

// Sync object
const config: Config.InitialOptions = {
  setupFilesAfterEnv: ['./jest.setup.ts'], // Reference the setup file
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.tsx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
};

export default config;
=======================

import React from "react";
import { render, screen } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with the correct path to your component

// Default props for the test
const defaultProps = {
  componentConfig: {
    fieldName: "testDate",
    fieldLabel: "Test Date",
    description: "Select a date",
  },
  section: "Test Section",
  handleChange: jest.fn(),
  value: "2025-01-01",
  errorMessage: "",
  readOnly: false,
};

describe("CLMDate Component", () => {
  it("renders the label and input field", () => {
    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Assert: Check if the label is displayed
    expect(screen.getByText("Test Date")).toBeInTheDocument();

    // Assert: Check if the input field with the correct value is rendered
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeInTheDocument();
    expect(input).toHaveAttribute("type", "date");
  });
});




import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import CLMDate from './CLMDate'; // Adjust the import path based on your project structure

jest.mock('@barclays/blueprint-react', () => ({
  __esModule: true,  // This line indicates that the module is an ES module
  ...jest.requireActual('@barclays/blueprint-react'),
  Icon: () => <span>MockIcon</span>,  // Mock the Icon component
}));

const visibilityRule = { linkedFieldName: 'someField', linkedFieldValue: true };

const componentConfig = {
  fieldName: 'date',
  fieldLabel: 'Date',
  componentType: 'input',
  description: 'Select a date',
  values: ['2025-01-16'],
  isVisible: visibilityRule,
  isEditable: true,
  validation: 'required'
};

test('renders CLMDate component', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  const inputElement = screen.getByLabelText('Date');
  expect(inputElement).toBeInTheDocument();
});

test('calls handleChange on input change', () => {
  const handleChange = jest.fn();
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={handleChange} readOnly={false} />);
  const inputElement = screen.getByLabelText('Date');
  fireEvent.change(inputElement, { target: { value: '2025-01-16' } });
  expect(handleChange).toHaveBeenCalledWith('date', '2025-01-16');
});

test('displays error message', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} errorMessage="Invalid date" />);
  const errorElement = screen.getByText('Invalid date');
  expect(errorElement).toBeInTheDocument();
});

test('renders component as editable or read-only based on isEditable property', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  const editableInputElement = screen.getByLabelText('Date');
  expect(editableInputElement).not.toBeDisabled();

  const readOnlyConfig = { ...componentConfig, isEditable: false };
  render(<CLMDate componentConfig={readOnlyConfig} value="" handleChange={() => {}} readOnly={true} />);
  const readOnlyInputElement = screen.getByLabelText('Date');
  expect(readOnlyInputElement).toBeDisabled();
});

=============================================================================
jest.mock('@barclays/blueprint-react', () => {
  const originalModule = jest.requireActual('@barclays/blueprint-react');
  return {
    ...originalModule,
    Icon: ({ icon }) => <span data-testid={`icon-${icon}`}>{icon}</span>, // Mock icon rendering
  };
});

===========================================================================
{
  "targets": {
    "test": {
      "executor": "@nrwl/jest:jest",
      "options": {
        "jestConfig": "apps/your-app/jest.config.ts",
        "passWithNoTests": true
      },
      "outputs": ["coverage/apps/your-app"]
    }
  }
}
==================================================================
nx generate @nrwl/jest:configuration your-app-or-lib-name

==================================================================
import { getJestProjects } from '@nrwl/jest';

export default {
  projects: getJestProjects(),
};
===================================================================
/* jest.config.ts */
export default {
  displayName: 'your-app',
  preset: '../../jest.preset.js',
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.[tj]sx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],
  coverageDirectory: '../../coverage/apps/your-app',
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
};
==================================================================
import '@testing-library/jest-dom';

==================================================================
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with your actual file path
import { ICLMDate } from "./CLMDate.types"; // Replace with your actual interface path

describe("CLMDate Component", () => {
  const mockHandleChange = jest.fn();

  const defaultProps: ICLMDate = {
    componentConfig: {
      fieldName: "testDate",
      fieldLabel: "Test Date",
      description: "Select a date",
    },
    handleChange: mockHandleChange,
    value: "2025-01-01",
    errorMessage: "",
    readOnly: false,
  };

  it("renders the component correctly", () => {
    render(<CLMDate {...defaultProps} />);

    // Check if label is rendered
    expect(screen.getByText("Test Date")).toBeInTheDocument();
    // Check if description is rendered
    expect(screen.getByText("Select a date")).toBeInTheDocument();
    // Check if input is rendered
    const input = screen.getByRole("textbox");
    expect(input).toBeInTheDocument();
    expect(input).toHaveValue("2025-01-01");
  });

  it("calls handleChange when input value changes", () => {
    render(<CLMDate {...defaultProps} />);

    const input = screen.getByRole("textbox");
    fireEvent.change(input, { target: { value: "2025-02-01" } });

    expect(mockHandleChange).toHaveBeenCalledTimes(1);
    expect(mockHandleChange).toHaveBeenCalledWith("testDate", "2025-02-01");
  });

  it("displays an error message if provided", () => {
    render(
      <CLMDate
        {...defaultProps}
        errorMessage="This field is required"
      />
    );

    // Check if the error message is displayed
    expect(screen.getByText("This field is required")).toBeInTheDocument();
  });

  it("disables the input when readOnly is true", () => {
    render(
      <CLMDate
        {...defaultProps}
        readOnly={true}
      />
    );

    const input = screen.getByRole("textbox");
    expect(input).toBeDisabled();
  });

  it("renders the calendar icon", () => {
    render(<CLMDate {...defaultProps} />);

    const calendarIcon = screen.getByLabelText("calendar");
    expect(calendarIcon).toBeInTheDocument();
  });

  it("renders without crashing when section prop is provided", () => {
    render(<CLMDate {...defaultProps} section="Test Section" />);

    // Check if component renders properly with the section prop
    expect(screen.getByText("Test Date")).toBeInTheDocument();
  });
});
=================================================================================================
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with the correct file path
import { ICLMdate } from "./CLMDate.types"; // Replace with the correct file path

const defaultProps: ICLMdate = {
  componentConfig: {
    fieldName: "testDate",
    fieldLabel: "Test Date",
    description: "Select a date",
  },
  section: "General",
  handleChange: jest.fn(),
  value: "2025-01-01",
  errorMessage: "",
  readOnly: false,
};

describe("CLMDate Component", () => {
  it("renders the component with label, description, and input field", () => {
    render(<CLMDate {...defaultProps} />);

    // Check the label
    expect(screen.getByText("Test Date")).toBeInTheDocument();

    // Check the description
    expect(screen.getByText("Select a date")).toBeInTheDocument();

    // Check the input field
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeInTheDocument();
    expect(input).toHaveAttribute("type", "date");
  });

  it("calls handleChange when the input value changes", () => {
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const input = screen.getByDisplayValue("2025-01-01");

    // Simulate changing the input value
    fireEvent.change(input, { target: { value: "2025-02-01" } });

    // Check if handleChange was called with the correct arguments
    expect(defaultProps.handleChange).toHaveBeenCalledWith(
      "testDate",
      "2025-02-01"
    );
  });

  it("displays an error message when errorMessage prop is provided", () => {
    const propsWithError = {
      ...defaultProps,
      errorMessage: "Invalid date",
    };

    render(<CLMDate {...propsWithError} />);

    // Check if the error message is displayed
    expect(screen.getByText("Invalid date")).toBeInTheDocument();
  });

  it("renders a disabled input when readOnly is true", () => {
    const readOnlyProps = {
      ...defaultProps,
      readOnly: true,
    };

    render(<CLMDate {...readOnlyProps} />);

    // Check if the input is disabled
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeDisabled();
  });
});
===========================================================================================
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import { CLMDate } from './CLMDate';
import { ICLMdate } from './CLMDate.types';

describe('CLMDate Component', () => {
  it('should render the CLMDate component correctly', () => {
    // Mock handleChange function
    const mockHandleChange = jest.fn();

    // Default props for the component
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: mockHandleChange,
      value: '2024-01-01',
      errorMessage: '',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find elements in the component
    const inputElement = screen.getByRole('textbox');
    const labelElement = screen.getByText('Test Label');
    const descriptionElement = screen.getByText('Test Description');

    // Assertions: Input field, label, and description should be present
    expect(inputElement).toBeInTheDocument();
    expect(labelElement).toBeInTheDocument();
    expect(descriptionElement).toBeInTheDocument();

    // Assert input attributes
    expect(inputElement).toHaveAttribute('type', 'date');
    expect(inputElement).toHaveAttribute('value', '2024-01-01');
    expect(inputElement).not.toBeDisabled();
  });

  it('should call handleChange when input value changes', () => {
    // Mock handleChange function
    const mockHandleChange = jest.fn();

    // Default props
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: mockHandleChange,
      value: '2024-01-01',
      errorMessage: '',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const inputElement = screen.getByRole('textbox');

    // Simulate a change event
    fireEvent.change(inputElement, { target: { value: '2024-02-01' } });

    // Assert handleChange was called with correct arguments
    expect(mockHandleChange).toHaveBeenCalledWith('testField', '2024-02-01');
  });

  it('should render an error message if provided', () => {
    // Default props with an error message
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: jest.fn(),
      value: '2024-01-01',
      errorMessage: 'Invalid date',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the error message
    const errorElement = screen.getByText('Invalid date');

    // Assert the error message is rendered
    expect(errorElement).toBeInTheDocument();
  });

  it('should disable the input field if readOnly is true', () => {
    // Default props with readOnly set to true
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: jest.fn(),
      value: '2024-01-01',
      errorMessage: '',
      readOnly: true,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const inputElement = screen.getByRole('textbox');

    // Assert the input field is disabled
    expect(inputElement).toBeDisabled();
  });
})
=================================================================================
test('renders CLMDate component', () => {
  const componentConfig = { fieldName: 'date', fieldLabel: 'Date', description: 'Select a date' };
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  
  const inputElement = screen.getByLabelText('Date');
  expect(inputElement).toBeInTheDocument();
});



---------------------------------------------------------------
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import ReviewAndAttest from './ReviewAndAttest';
import { useApiProvider } from './../../../hooks/useApiProvider';

// Mock the `useApiProvider` hook
jest.mock('./../../../hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(),
}));

describe('ReviewAndAttest Component', () => {
  const mockReviewAndAttestData = jest.fn();

  beforeEach(() => {
    (useApiProvider as jest.Mock).mockReturnValue({
      reviewAndAttestData: mockReviewAndAttestData,
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('renders the Panel component correctly', () => {
    render(<ReviewAndAttest />);
    const panel = screen.getByTestId('panel');
    expect(panel).toBeInTheDocument();
    expect(panel).toHaveStyle({ marginBottom: '0.75em' });
  });

  test('renders the Button with the correct props', () => {
    render(<ReviewAndAttest />);
    const button = screen.getByRole('button', { name: /review & attest/i });

    expect(button).toBeInTheDocument();
    expect(button).toHaveAttribute('variant', 'primary');
    expect(button).toHaveAttribute('mediaPosition', 'right');
  });

  test('renders the Icon inside the Button', () => {
    render(<ReviewAndAttest />);
    const icon = screen.getByTestId('icon'); // If your Icon component uses a `data-testid`
    expect(icon).toBeInTheDocument();
    expect(icon).toHaveAttribute('icon', 'document');
    expect(icon).toHaveAttribute('size', 'sm');
  });

  test('calls reviewAndAttestData on Button click', () => {
    render(<ReviewAndAttest />);
    const button = screen.getByRole('button', { name: /review & attest/i });

    fireEvent.click(button);

    // Verify the function was called
    expect(mockReviewAndAttestData).toHaveBeenCalledTimes(1);
  });
});

====================================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom'; // For additional matchers like 'toBeInTheDocument'
import ReviewAndAttest from './ReviewAndAttest';
import { useApiProvider } from './../../../hooks/useApiProvider';

// Mock the `useApiProvider` hook
jest.mock('./../../../hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(),
}));

describe('ReviewAndAttest Component', () => {
  const mockReviewAndAttestData = jest.fn();

  beforeEach(() => {
    (useApiProvider as jest.Mock).mockReturnValue({
      reviewAndAttestData: mockReviewAndAttestData,
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('renders the component correctly', () => {
    render(<ReviewAndAttest />);

    // Assert that the button is in the document
    const button = screen.getByRole('button', { name: /review & attest/i });
    expect(button).toBeInTheDocument();

    // Assert that the icon is rendered
    const icon = screen.getByTestId('icon'); // Assuming Icon has a `data-testid` or equivalent
    expect(icon).toBeInTheDocument();
  });

  test('button click calls the reviewAndAttestData function', () => {
    render(<ReviewAndAttest />);

    const button = screen.getByRole('button', { name: /review & attest/i });
    fireEvent.click(button);

    // Assert that the API function was called
    expect(mockReviewAndAttestData).toHaveBeenCalledTimes(1);
  });

  test('button has correct styling and properties', () => {
    render(<ReviewAndAttest />);

    const button = screen.getByRole('button', { name: /review & attest/i });

    // Assert button has the correct classes or attributes
    expect(button).toHaveClass('bp3-button'); // Adjust for Blueprint class
    expect(button).toHaveAttribute('variant', 'primary');
    expect(button).toHaveAttribute('mediaPosition', 'right');
  });
});

=======================================================================
<button
  data-testid="alert-dismiss-button"
  onClick={() => contentProvider?.updateFcrmAlerts(undefined)}
>
  Dismiss
</button>

=======================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    const dismissButton = screen.getByText('Dismiss');
    fireEvent.click(dismissButton);

    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  // Additional tests for completeness
  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });

  it('handles missing updateFcrmAlerts function gracefully', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: null,
    });

    render(<Alerts />);

    const dismissButton = screen.getByText('Dismiss');
    fireEvent.click(dismissButton);

    // No error should be thrown, but there's no function to call
    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
  });

  it('renders without crashing when useContentProvider fails', () => {
    useContentProvider.mockImplementation(() => {
      throw new Error('Failed to fetch content provider');
    });

    expect(() => render(<Alerts />)).not.toThrow();
  });

  it('renders default message when status is unknown', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'unknown',
        message: 'Unknown status!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Unknown:')).toBeInTheDocument();
    expect(screen.getByText('Unknown status!')).toBeInTheDocument();
  });

  it('has correct ARIA attributes for accessibility', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
    expect(screen.getByRole('alert')).toHaveAttribute('aria-live', 'assertive');
  });
});
=================================================================================

onDismiss={() => {
  console.log('onDismiss called'); // Debug log
  contentProvider?.updateFcrmAlerts(undefined);
}}



it('does not throw error if updateFcrmAlerts is not defined', () => {
  useContentProvider.mockReturnValue({
    fcrmAlert: {
      status: 'success',
      message: 'Operation successful',
    },
  });

  render(<Alerts />);
  const dismissButton = screen.getByRole('button', { name: /dismiss/i });

  // Simulate dismiss action
  expect(() => fireEvent.click(dismissButton)).not.toThrow();
});


it('matches snapshot for success state', () => {
  useContentProvider.mockReturnValue({
    fcrmAlert: {
      status: 'success',
      message: 'Operation successful',
    },
  });

  const { asFragment } = render(<Alerts />);
  expect(asFragment()).toMatchSnapshot();
});


======================================================
it('does not render Alert when contentProvider is null', () => {
  useContentProvider.mockReturnValue(null);

  const { container } = render(<Alerts />);
  expect(container.firstChild).toBeNull();
});

=============================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    const dismissButton = screen.getByRole('button', { name: /dismiss/i });
    fireEvent.click(dismissButton);

    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });
});

=============================================================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    fireEvent.click(screen.getByRole('button', { name: /dismiss/i }));
    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });
});



===================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts';
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });
});

======================================================================================================

import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts';
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
  });

  it('renders error status and message', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
  });
});
===============================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import Alerts from './alert'; // Adjust the import path as needed
import { useContentProvider } from '../../hooks/useContentProvider';

// Mock the `useContentProvider` hook
jest.mock('../../hooks/useContentProvider', () => ({
  useContentProvider: jest.fn(),
}));

describe('Alerts Component', () => {
  it('renders the Alert with success status and message', () => {
    // Mock data for the content provider
    const mockContentProvider = {
      fcrmAlert: {
        status: 'success',
        message: 'Operation completed successfully.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Check if the Alert is rendered with success status
    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation completed successfully.')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders the Alert with error status and message', () => {
    const mockContentProvider = {
      fcrmAlert: {
        status: 'error',
        message: 'There was an error processing your request.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Check if the Alert is rendered with error status
    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('There was an error processing your request.')).toBeInTheDocument();
  });

  it('calls onDismiss when the Alert is dismissed', () => {
    const mockContentProvider = {
      fcrmAlert: {
        status: 'success',
        message: 'Operation completed successfully.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Simulate the dismiss action
    const dismissButton = screen.getByRole('button');
    fireEvent.click(dismissButton);

    // Verify that `updateFcrmAlerts` was called
    expect(mockContentProvider.updateFcrmAlerts).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if fcrmAlert is undefined', () => {
    const mockContentProvider = {
      fcrmAlert: undefined,
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    const { container } = render(<Alerts />);

    // Check that nothing is rendered
    expect(container.firstChild).toBeNull();
  });
});

=========================================================================================
jest.mock('@barclays/clm-react-document', () => ({
  ...jest.requireActual('@barclays/clm-react-document'), // Include other actual exports
  ClmReactDocumentUploader: jest.fn((props) => (
    <div data-testid="mock-document-uploader">
      Mock Document Uploader
      <button onClick={props.onFilesUpload}>Upload Files</button>
    </div>
  )),
}));

jest.mock('./CLMUploadDocDetails', () => jest.fn(() => <div data-testid="mock-upload-details">Mock Upload Details</div>));
jest.mock('../../../Fcrm/hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(() => ({
    someMethod: jest.fn(),
  })),
}));
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import YourComponent from './YourComponent';

test('renders mock components correctly', () => {
  render(<YourComponent />);

  // Verify that the mocked `ClmReactDocumentUploader` is rendered
  expect(screen.getByTestId('mock-document-uploader')).toBeInTheDocument();

  // Verify that the mocked `CLMUploadDocDetails` is rendered
  expect(screen.getByTestId('mock-upload-details')).toBeInTheDocument();
});

test('calls onFilesUpload when upload button is clicked', () => {
  const onFilesUpload = jest.fn();

  render(
    <YourComponent
      ClmReactDocumentUploader={{
        onFilesUpload,
      }}
    />
  );

  const uploadButton = screen.getByText('Upload Files');
  fireEvent.click(uploadButton);

  expect(onFilesUpload).toHaveBeenCalledTimes(1);
});

====================================================================

jest.mock('@barclays/clm-react-docum', () => ({
  ClmReactDocumentUploader: jest.fn(() => <div>Mock Uploader</div>),
}));

jest.mock('./CLMUploadDocDetails', () => jest.fn(() => <div>Mock Upload Details</div>));

=====================================================================
const nxPreset = require("@nx/jest/preset");

module.exports = {
  ...nxPreset,
  testEnvironment: "jest-environment-jsdom",
  transform: {
    "^.+\\.[tj]sx?$": "babel-jest",
  },
};
=====================================================================
import React from "react";

const MyComponent: React.FC = () => {
  return <div>Hello, Jest!</div>;
};

export default MyComponent;

=====================================================================
import React from "react";
import { render, screen } from "@testing-library/react";
import MyComponent from "./MyComponent";

describe("MyComponent", () => {
  it("renders correctly", () => {
    render(<MyComponent />);
    expect(screen.getByText("Hello, Jest!")).toBeInTheDocument();
  });
});

================================================================================

npm install --save @nx/react react react-dom
npm install --save-dev @babel/core babel-jest @babel/preset-env @babel/preset-react @babel/preset-typescript jest ts-jest typescript

npm install --save-dev babel-jest @babel/core @babel/preset-env @babel/preset-react
npm install --save-dev @babel/preset-typescript
========================================================

import React from 'react';
import { render, fireEvent } from '@testing-library/react';
import { CLMSelect } from './CLMSelect';

describe('CLMSelect Component', () => {
  it('should render the options and call handleChange on selection', () => {
    // Manual mock function
    const mockHandleChange = (fieldName: string, value: any) => {
      console.log(`handleChange called with fieldName: ${fieldName}, value: ${value}`);
    };

    const mockConfig = {
      fieldName: 'selectField',
      fieldLabel: 'Select Option',
      fieldDescription: 'Choose an option',
      values: ['Option 1', 'Option 2', 'Option 3'],
    };

    const { getByLabelText, getByRole } = render(
      <CLMSelect
        componentConfig={mockConfig}
        section="test-section"
        handleChange={mockHandleChange}
        value="Option 1"
        readOnly={false}
      />
    );

    // Check if options are rendered
    expect(getByRole('option', { name: 'Option 1' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 2' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 3' })).toBeInTheDocument();

    // Simulate user selecting a new option
    fireEvent.change(getByLabelText('Select Option'), { target: { value: 'Option 2' } });

    // Output will be visible in the console
  });
});

===========================================================================
import React from 'react';
import { render, fireEvent } from '@testing-library/react';
import { CLMSelect } from './CLMSelect';

describe('CLMSelect Component', () => {
  it('should render the options and call handleChange on selection', () => {
    const mockHandleChange = jest.fn();

    const mockConfig = {
      fieldName: 'selectField',
      fieldLabel: 'Select Option',
      fieldDescription: 'Choose an option',
      values: ['Option 1', 'Option 2', 'Option 3'],
    };

    const { getByLabelText, getByRole } = render(
      <CLMSelect
        componentConfig={mockConfig}
        section="test-section"
        handleChange={mockHandleChange}
        value="Option 1"
        readOnly={false}
      />
    );

    // Check if options are rendered
    expect(getByRole('option', { name: 'Option 1' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 2' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 3' })).toBeInTheDocument();

    // Simulate user selecting a new option
    fireEvent.change(getByLabelText('Select Option'), { target: { value: 'Option 2' } });

    // Check if handleChange was called
    expect(mockHandleChange).toHaveBeenCalledWith('selectField', 'Option 2');
  });
});

=======================================================================================
{
  "name": "<your-project-name>",
  "targets": {
    "test": {
      "executor": "@nrwl/jest:jest",
      "options": {
        "jestConfig": "apps/<your-project-name>/jest.config.ts",
        "passWithNoTests": true
      },
      "outputs": ["coverage/apps/<your-project-name>"]
    }
  }
}

==========================================
const nxPreset = require('@nx/jest/preset').default;

module.exports = { ...nxPreset };

===============================================================

import { getJestProjects } from '@nx/jest';

export default {
  displayName: '<your-project-name>',
  preset: '../../jest.preset.js',
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
  globals: {},
  transform: {
    '^.+\\.[tj]sx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],
  coverageDirectory: '../../coverage/apps/<your-project-name>',
  testEnvironment: 'jsdom', // Use 'node' if not React-based
};

===============================================================


===============================================================
{
  "projects": {
    "clm-ui-fcrm": {
      "root": "apps/clm-ui-fcrm",
      "sourceRoot": "apps/clm-ui-fcrm/src",
      "projectType": "application",
      "targets": {
        "test": {
          "executor": "@nrwl/jest:jest",
          "outputs": ["coverage/apps/clm-ui-fcrm"],
          "options": {
            "jestConfig": "apps/clm-ui-fcrm/jest.config.ts",
            "passWithNoTests": true
          }
        }
      }
    }
  }
}

=========================================================================
import { Config } from '@jest/types';

// Sync object
const config: Config.InitialOptions = {
  setupFilesAfterEnv: ['./jest.setup.ts'], // Reference the setup file
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.tsx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
};

export default config;
=======================

import React from "react";
import { render, screen } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with the correct path to your component

// Default props for the test
const defaultProps = {
  componentConfig: {
    fieldName: "testDate",
    fieldLabel: "Test Date",
    description: "Select a date",
  },
  section: "Test Section",
  handleChange: jest.fn(),
  value: "2025-01-01",
  errorMessage: "",
  readOnly: false,
};

describe("CLMDate Component", () => {
  it("renders the label and input field", () => {
    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Assert: Check if the label is displayed
    expect(screen.getByText("Test Date")).toBeInTheDocument();

    // Assert: Check if the input field with the correct value is rendered
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeInTheDocument();
    expect(input).toHaveAttribute("type", "date");
  });
});




import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import CLMDate from './CLMDate'; // Adjust the import path based on your project structure

jest.mock('@barclays/blueprint-react', () => ({
  __esModule: true,  // This line indicates that the module is an ES module
  ...jest.requireActual('@barclays/blueprint-react'),
  Icon: () => <span>MockIcon</span>,  // Mock the Icon component
}));

const visibilityRule = { linkedFieldName: 'someField', linkedFieldValue: true };

const componentConfig = {
  fieldName: 'date',
  fieldLabel: 'Date',
  componentType: 'input',
  description: 'Select a date',
  values: ['2025-01-16'],
  isVisible: visibilityRule,
  isEditable: true,
  validation: 'required'
};

test('renders CLMDate component', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  const inputElement = screen.getByLabelText('Date');
  expect(inputElement).toBeInTheDocument();
});

test('calls handleChange on input change', () => {
  const handleChange = jest.fn();
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={handleChange} readOnly={false} />);
  const inputElement = screen.getByLabelText('Date');
  fireEvent.change(inputElement, { target: { value: '2025-01-16' } });
  expect(handleChange).toHaveBeenCalledWith('date', '2025-01-16');
});

test('displays error message', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} errorMessage="Invalid date" />);
  const errorElement = screen.getByText('Invalid date');
  expect(errorElement).toBeInTheDocument();
});

test('renders component as editable or read-only based on isEditable property', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  const editableInputElement = screen.getByLabelText('Date');
  expect(editableInputElement).not.toBeDisabled();

  const readOnlyConfig = { ...componentConfig, isEditable: false };
  render(<CLMDate componentConfig={readOnlyConfig} value="" handleChange={() => {}} readOnly={true} />);
  const readOnlyInputElement = screen.getByLabelText('Date');
  expect(readOnlyInputElement).toBeDisabled();
});

=============================================================================
jest.mock('@barclays/blueprint-react', () => {
  const originalModule = jest.requireActual('@barclays/blueprint-react');
  return {
    ...originalModule,
    Icon: ({ icon }) => <span data-testid={`icon-${icon}`}>{icon}</span>, // Mock icon rendering
  };
});

===========================================================================
{
  "targets": {
    "test": {
      "executor": "@nrwl/jest:jest",
      "options": {
        "jestConfig": "apps/your-app/jest.config.ts",
        "passWithNoTests": true
      },
      "outputs": ["coverage/apps/your-app"]
    }
  }
}
==================================================================
nx generate @nrwl/jest:configuration your-app-or-lib-name

==================================================================
import { getJestProjects } from '@nrwl/jest';

export default {
  projects: getJestProjects(),
};
===================================================================
/* jest.config.ts */
export default {
  displayName: 'your-app',
  preset: '../../jest.preset.js',
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.[tj]sx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],
  coverageDirectory: '../../coverage/apps/your-app',
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
};
==================================================================
import '@testing-library/jest-dom';

==================================================================
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with your actual file path
import { ICLMDate } from "./CLMDate.types"; // Replace with your actual interface path

describe("CLMDate Component", () => {
  const mockHandleChange = jest.fn();

  const defaultProps: ICLMDate = {
    componentConfig: {
      fieldName: "testDate",
      fieldLabel: "Test Date",
      description: "Select a date",
    },
    handleChange: mockHandleChange,
    value: "2025-01-01",
    errorMessage: "",
    readOnly: false,
  };

  it("renders the component correctly", () => {
    render(<CLMDate {...defaultProps} />);

    // Check if label is rendered
    expect(screen.getByText("Test Date")).toBeInTheDocument();
    // Check if description is rendered
    expect(screen.getByText("Select a date")).toBeInTheDocument();
    // Check if input is rendered
    const input = screen.getByRole("textbox");
    expect(input).toBeInTheDocument();
    expect(input).toHaveValue("2025-01-01");
  });

  it("calls handleChange when input value changes", () => {
    render(<CLMDate {...defaultProps} />);

    const input = screen.getByRole("textbox");
    fireEvent.change(input, { target: { value: "2025-02-01" } });

    expect(mockHandleChange).toHaveBeenCalledTimes(1);
    expect(mockHandleChange).toHaveBeenCalledWith("testDate", "2025-02-01");
  });

  it("displays an error message if provided", () => {
    render(
      <CLMDate
        {...defaultProps}
        errorMessage="This field is required"
      />
    );

    // Check if the error message is displayed
    expect(screen.getByText("This field is required")).toBeInTheDocument();
  });

  it("disables the input when readOnly is true", () => {
    render(
      <CLMDate
        {...defaultProps}
        readOnly={true}
      />
    );

    const input = screen.getByRole("textbox");
    expect(input).toBeDisabled();
  });

  it("renders the calendar icon", () => {
    render(<CLMDate {...defaultProps} />);

    const calendarIcon = screen.getByLabelText("calendar");
    expect(calendarIcon).toBeInTheDocument();
  });

  it("renders without crashing when section prop is provided", () => {
    render(<CLMDate {...defaultProps} section="Test Section" />);

    // Check if component renders properly with the section prop
    expect(screen.getByText("Test Date")).toBeInTheDocument();
  });
});
=================================================================================================
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with the correct file path
import { ICLMdate } from "./CLMDate.types"; // Replace with the correct file path

const defaultProps: ICLMdate = {
  componentConfig: {
    fieldName: "testDate",
    fieldLabel: "Test Date",
    description: "Select a date",
  },
  section: "General",
  handleChange: jest.fn(),
  value: "2025-01-01",
  errorMessage: "",
  readOnly: false,
};

describe("CLMDate Component", () => {
  it("renders the component with label, description, and input field", () => {
    render(<CLMDate {...defaultProps} />);

    // Check the label
    expect(screen.getByText("Test Date")).toBeInTheDocument();

    // Check the description
    expect(screen.getByText("Select a date")).toBeInTheDocument();

    // Check the input field
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeInTheDocument();
    expect(input).toHaveAttribute("type", "date");
  });

  it("calls handleChange when the input value changes", () => {
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const input = screen.getByDisplayValue("2025-01-01");

    // Simulate changing the input value
    fireEvent.change(input, { target: { value: "2025-02-01" } });

    // Check if handleChange was called with the correct arguments
    expect(defaultProps.handleChange).toHaveBeenCalledWith(
      "testDate",
      "2025-02-01"
    );
  });

  it("displays an error message when errorMessage prop is provided", () => {
    const propsWithError = {
      ...defaultProps,
      errorMessage: "Invalid date",
    };

    render(<CLMDate {...propsWithError} />);

    // Check if the error message is displayed
    expect(screen.getByText("Invalid date")).toBeInTheDocument();
  });

  it("renders a disabled input when readOnly is true", () => {
    const readOnlyProps = {
      ...defaultProps,
      readOnly: true,
    };

    render(<CLMDate {...readOnlyProps} />);

    // Check if the input is disabled
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeDisabled();
  });
});
===========================================================================================
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import { CLMDate } from './CLMDate';
import { ICLMdate } from './CLMDate.types';

describe('CLMDate Component', () => {
  it('should render the CLMDate component correctly', () => {
    // Mock handleChange function
    const mockHandleChange = jest.fn();

    // Default props for the component
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: mockHandleChange,
      value: '2024-01-01',
      errorMessage: '',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find elements in the component
    const inputElement = screen.getByRole('textbox');
    const labelElement = screen.getByText('Test Label');
    const descriptionElement = screen.getByText('Test Description');

    // Assertions: Input field, label, and description should be present
    expect(inputElement).toBeInTheDocument();
    expect(labelElement).toBeInTheDocument();
    expect(descriptionElement).toBeInTheDocument();

    // Assert input attributes
    expect(inputElement).toHaveAttribute('type', 'date');
    expect(inputElement).toHaveAttribute('value', '2024-01-01');
    expect(inputElement).not.toBeDisabled();
  });

  it('should call handleChange when input value changes', () => {
    // Mock handleChange function
    const mockHandleChange = jest.fn();

    // Default props
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: mockHandleChange,
      value: '2024-01-01',
      errorMessage: '',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const inputElement = screen.getByRole('textbox');

    // Simulate a change event
    fireEvent.change(inputElement, { target: { value: '2024-02-01' } });

    // Assert handleChange was called with correct arguments
    expect(mockHandleChange).toHaveBeenCalledWith('testField', '2024-02-01');
  });

  it('should render an error message if provided', () => {
    // Default props with an error message
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: jest.fn(),
      value: '2024-01-01',
      errorMessage: 'Invalid date',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the error message
    const errorElement = screen.getByText('Invalid date');

    // Assert the error message is rendered
    expect(errorElement).toBeInTheDocument();
  });

  it('should disable the input field if readOnly is true', () => {
    // Default props with readOnly set to true
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: jest.fn(),
      value: '2024-01-01',
      errorMessage: '',
      readOnly: true,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const inputElement = screen.getByRole('textbox');

    // Assert the input field is disabled
    expect(inputElement).toBeDisabled();
  });
})
=================================================================================
test('renders CLMDate component', () => {
  const componentConfig = { fieldName: 'date', fieldLabel: 'Date', description: 'Select a date' };
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  
  const inputElement = screen.getByLabelText('Date');
  expect(inputElement).toBeInTheDocument();
});



