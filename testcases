import { describe, it, expect, vi } from "vitest";

// Mocked function implementations
const updatePep = vi.fn();
const updateForeignDomesticPep = vi.fn();
const updateBooleanRiskItem = vi.fn();

// Function to test
function updateBooleanRisk(answer: boolean, booleanRiskType: string) {
  switch (booleanRiskType) {
    case "pep":
      updatePep(answer);
      break;
    case "foreignDomestic":
      updateForeignDomesticPep(answer);
      break;
    case "standard":
      updateBooleanRiskItem(answer);
      break;
    default:
      return;
  }
}

describe("updateBooleanRisk function", () => {
  it("calls updatePep when booleanRiskType is 'pep'", () => {
    updateBooleanRisk(true, "pep");
    expect(updatePep).toHaveBeenCalledWith(true);
  });

  it("calls updateForeignDomesticPep when booleanRiskType is 'foreignDomestic'", () => {
    updateBooleanRisk(false, "foreignDomestic");
    expect(updateForeignDomesticPep).toHaveBeenCalledWith(false);
  });

  it("calls updateBooleanRiskItem when booleanRiskType is 'standard'", () => {
    updateBooleanRisk(true, "standard");
    expect(updateBooleanRiskItem).toHaveBeenCalledWith(true);
  });

  it("does nothing for unknown booleanRiskType", () => {
    updateBooleanRisk(true, "unknownType");
    expect(updatePep).not.toHaveBeenCalled();
    expect(updateForeignDomesticPep).not.toHaveBeenCalled();
    expect(updateBooleanRiskItem).not.toHaveBeenCalled();
  });
});

==============================================Boolean
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import BooleanListener from './BooleanListener'; // Adjust the import path
import { describe, it, expect, vi } from 'vitest';

// Mock Redux store for testing
const mockStore = configureStore({
  reducer: {
    riskItems: () => ({}),
    riskTolerance: () => ({}),
  },
});

// Mock functions using `vi`
vi.mock('src/Fcrm/hooks/useRiskScoreProvider.tsx', () => ({
  useRiskScoreProvider: vi.fn(() => ({
    getBooleanQuestionSubtype: vi.fn(() => 'standard'),
    updateBooleanRisk: vi.fn(),
    updatePepRisk: vi.fn(),
    removeBooleanRisk: vi.fn(),
  })),
}));

vi.mock('src/redux/selectors/generalDatas', () => ({
  getFcrmEntryField: vi.fn(() => ({
    fieldName: 'testField',
    value: 'Yes',
  })),
  getInvalidFieldsErrorPanelState: vi.fn(() => true),
}));

vi.mock('src/redux/slices/validationStatusSlice.ts', () => ({
  changeFieldIsValidIsVisibleUpdate: vi.fn(),
  changeFieldNotValidIsVisibleUpdate: vi.fn(),
  changeFieldVisibilityRemoval: vi.fn(),
  updateFieldValidationStatusNotValidNotVisible: vi.fn(),
}));

// Import the mocked `useRiskScoreProvider`
import { useRiskScoreProvider } from 'src/Fcrm/hooks/useRiskScoreProvider.tsx';

// Test suite
describe('BooleanListener Component', () => {
  it('renders without crashing', () => {
    render(
      <Provider store={mockStore}>
        <BooleanListener fieldName="testField" section="testSection" />
      </Provider>
    );

    expect(screen.getByText('Error: this is a required field')).toBeInTheDocument();
  });

  it('calls updateBooleanRisk when value changes', async () => {
    const { getByLabelText } = render(
      <Provider store={mockStore}>
        <BooleanListener fieldName="testField" section="testSection" />
      </Provider>
    );

    // Simulate field change
    const radioButtonYes = getByLabelText(/Yes/i);
    fireEvent.click(radioButtonYes);

    await waitFor(() => {
      expect(useRiskScoreProvider().updateBooleanRisk).toHaveBeenCalled();
    });
  });

  it('displays error message when field is required and not filled', async () => {
    const { getByText, getByLabelText } = render(
      <Provider store={mockStore}>
        <BooleanListener fieldName="testField" section="testSection" />
      </Provider>
    );

    const radioButtonNo = getByLabelText(/No/i);
    fireEvent.click(radioButtonNo);

    await waitFor(() => {
      expect(getByText('Error: this is a required field')).toBeInTheDocument();
    });
  });

  it('updates the form state when value is updated', async () => {
    const { getByLabelText } = render(
      <Provider store={mockStore}>
        <BooleanListener fieldName="testField" section="testSection" />
      </Provider>
    );

    const radioButtonYes = getByLabelText(/Yes/i);
    fireEvent.click(radioButtonYes);

    await waitFor(() => {
      expect(getByLabelText(/Yes/i)).toBeChecked();
    });
  });

  it('does not call updateBooleanRisk if the value is unchanged', async () => {
    const { getByLabelText } = render(
      <Provider store={mockStore}>
        <BooleanListener fieldName="testField" section="testSection" />
      </Provider>
    );

    // First, simulate clicking "Yes"
    const radioButtonYes = getByLabelText(/Yes/i);
    fireEvent.click(radioButtonYes);

    // Then simulate clicking "No" (should not call `updateBooleanRisk` if logic prevents redundant calls)
    const radioButtonNo = getByLabelText(/No/i);
    fireEvent.click(radioButtonNo);

    await waitFor(() => {
      expect(useRiskScoreProvider().updateBooleanRisk).not.toHaveBeenCalledTimes(2);
    });
  });
});

============================================================
import { render, waitFor } from "@testing-library/react";
import { vi } from "vitest";
import YourComponent from "../YourComponent"; // Adjust the path

describe("YourComponent", () => {
  const clearErrors = vi.fn();
  const setError = vi.fn();
  const removeRiskItem = vi.fn();
  const updateRiskItems = vi.fn();
  const setErrorMessage = vi.fn();
  const dispatch = vi.fn();

  beforeEach(() => {
    // Reset mocks before each test
    vi.clearAllMocks();
  });

  test("should clear errors when showErrors is false or errorMessage is empty", async () => {
    render(
      <YourComponent 
        showErrors={false} 
        errorMessage="" 
        clearErrors={clearErrors} 
        fieldName="testField" 
        setError={setError} 
      />
    );

    await waitFor(() => {
      expect(clearErrors).toHaveBeenCalledWith("testField");
    });
  });

  test("should set error when showErrors is true and errorMessage is not empty", async () => {
    const errorMessage = "This field is required";

    render(
      <YourComponent 
        showErrors={true} 
        errorMessage={errorMessage} 
        clearErrors={clearErrors} 
        fieldName="testField" 
        setError={setError} 
      />
    );

    await waitFor(() => {
      expect(setError).toHaveBeenCalledWith("testField", { type: "custom", message: errorMessage });
    });
  });

  test("should remove risk items when isVisible is false and previousData is defined", async () => {
    const previousData = { option1: 50, option2: 30 };

    render(
      <YourComponent 
        isVisible={false} 
        previousData={previousData} 
        removeRiskItem={removeRiskItem} 
        dispatch={dispatch} 
      />
    );

    await waitFor(() => {
      Object.entries(previousData).forEach(([option, percentage]) => {
        expect(removeRiskItem).toHaveBeenCalledWith(option, percentage);
      });
    });
  });

  test("should update risk items when isVisible is true and previousData is defined", async () => {
    const previousData = { option1: 50, option2: 30 };

    render(
      <YourComponent 
        isVisible={true} 
        previousData={previousData} 
        updateRiskItems={updateRiskItems} 
        dispatch={dispatch} 
      />
    );

    await waitFor(() => {
      Object.entries(previousData).forEach(([option, percentage]) => {
        expect(updateRiskItems).toHaveBeenCalledWith(option, percentage);
      });
    });
  });

  test("should set error message when rhfFieldData is undefined", async () => {
    render(
      <YourComponent 
        rhfFieldData={undefined} 
        setErrorMessage={setErrorMessage} 
      />
    );

    await waitFor(() => {
      expect(setErrorMessage).toHaveBeenCalledWith('Error: this is a required field');
    });
  });
});
==============================
import { getRiskTolerance } from './yourModule'; // Adjust the import based on your file structure
import { store } from './yourStore'; // Adjust the import based on your file structure

describe('getRiskTolerance', () => {
  it('should return risk tolerance from the store', () => {
    const mockState = {
      riskTolerance: { level: 'medium' },
    };
    store.getState = jest.fn().mockReturnValue(mockState); // Mock the store's getState method

    const result = getRiskTolerance();

    expect(result).toEqual(mockState.riskTolerance);
  });
});
================================================
import { removeRiskItem } from './yourModule'; // Adjust the import based on your file structure

describe('removeRiskItem', () => {
  it('should return early if removedItem.option is undefined', () => {
    const removedItem = { option: undefined };
    const result = removeRiskItem(removedItem);
    expect(result).toBeUndefined(); // Adjust based on what the function returns
  });

  it('should return early if riskData is undefined', () => {
    const removedItem = { option: 'someOption' };
    const result = removeRiskItem(removedItem);
    expect(result).toBeUndefined(); // Adjust based on what the function returns
  });

  // Add more tests to cover other scenarios
});
=================================================================
import { getExistingRiskData } from './yourModule'; // Adjust the import based on your file structure
import { getPicklist } from './yourPicklistModule'; // Adjust the import based on your file structure

jest.mock('./yourPicklistModule'); // Mock the module that contains getPicklist

describe('getExistingRiskData', () => {
  it('should return existing risk data with risk categories', () => {
    const mockPicklist = new Map([
      ["Tech", ["High"]],
      ["Finance", ["Low"]],
    ]);
    
    getPicklist.mockReturnValue(mockPicklist); // Mock the return value of getPicklist

    const result = getExistingRiskData();

    expect(result.riskCategories).toEqual(mockPicklist);
  });
});
============================================================================
import { vi } from "vitest";
import { getExistingRiskData, removeRiskItem, updateThresholdData, getRiskTolerance } from "../yourFile";
import { store } from "../store"; // Adjust the import path as needed

// Mock dependencies
const getPicklist = vi.fn(() => new Map([["Tech", ["High"]], ["Finance", ["Low"]]]));
const dispatch = vi.fn();
store.dispatch = dispatch;

describe("Risk Data Functions", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  test("getExistingRiskData should return riskCategories from getPicklist", () => {
    const result = getExistingRiskData();
    expect(result.riskCategories).toEqual(getPicklist());
    expect(getPicklist).toHaveBeenCalled();
  });

  test("removeRiskItem should return early if removedItem.option is undefined", () => {
    expect(removeRiskItem({ option: undefined })).toBeUndefined();
  });

  test("removeRiskItem should return early if riskData is undefined", () => {
    vi.spyOn(riskProvider, "getQuestion").mockReturnValue(undefined);
    expect(removeRiskItem({ option: "Tech" })).toBeUndefined();
  });

  test("removeRiskItem should call updateThresholdData if thresholdUpdateResponse is defined", () => {
    const mockThresholdResponse = { newMultiSelectAnswers: { Tech: ["High"] } };
    vi.spyOn(riskProvider, "getQuestion").mockReturnValue(mockThresholdResponse);
    const updateThresholdDataMock = vi.spyOn(global, "updateThresholdData").mockImplementation(() => {});
    
    removeRiskItem({ option: "Tech" });

    expect(updateThresholdDataMock).toHaveBeenCalledWith(mockThresholdResponse);
  });

  test("updateThresholdData should update store with new risk thresholds", () => {
    const mockThresholdResponse = { newMultiSelectAnswers: { Tech: ["High"], Finance: [] } };
    updateThresholdData(mockThresholdResponse);

    expect(dispatch).toHaveBeenCalledWith({
      type: "updateMultiselectThresholds",
      payload: { newMultiSelectAnswers: { Tech: ["High"] } } // Finance should be removed
    });
  });

  test("getRiskTolerance should return riskTolerance from Redux store", () => {
    vi.spyOn(store, "getState").mockReturnValue({
      riskTolerance: { Tech: "High", Finance: "Low" }
    });

    const result = getRiskTolerance();
    expect(result).toEqual({ Tech: "High", Finance: "Low" });
  });
});
=====================================================

import { getErrorMessage, getChangedData, getPicklist } from "../riskDataUpdater";
import { store } from "../../store";

jest.mock("../../store", () => ({
  store: {
    getState: jest.fn(),
  },
}));

describe("riskDataUpdater", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("getErrorMessage", () => {
    it("should return required field error when map is empty", () => {
      const thresholdData = new Map();
      expect(getErrorMessage(thresholdData)).toBe("Error: this is a required field");
    });

    it("should return error for percentage less than 1", () => {
      const thresholdData = new Map([["Option1", 0]]);
      expect(getErrorMessage(thresholdData)).toBe("Error: percentages cannot be less than 1%");
    });

    it("should return error for percentage greater than 100", () => {
      const thresholdData = new Map([["Option1", 110]]);
      expect(getErrorMessage(thresholdData)).toBe("Error: percentages cannot be greater than 100%");
    });

    it("should return an empty string if all percentages are valid", () => {
      const thresholdData = new Map([["Option1", 50]]);
      expect(getErrorMessage(thresholdData)).toBe("");
    });
  });

  describe("getChangedData", () => {
    it("should detect additions and removals correctly", () => {
      const previousData = new Map([
        ["Option1", 50],
        ["Option2", 20],
      ]);
      const newItems = new Map([
        ["Option1", 50], // unchanged
        ["Option3", 30], // new addition
      ]);

      const result = getChangedData(newItems);
      expect(result.addition).toEqual({ option: "Option3", percentage: 30 });
      expect(result.removal).toEqual({ option: "Option2", percentage: 20 });
    });

    it("should return empty changes when no difference", () => {
      const previousData = new Map([
        ["Option1", 50],
      ]);
      const newItems = new Map([
        ["Option1", 50],
      ]);

      const result = getChangedData(newItems);
      expect(result.addition).toEqual({ option: "", percentage: 0 });
      expect(result.removal).toEqual({ option: "", percentage: 0 });
    });
  });

  describe("getPicklist", () => {
    it("should return country risks if picklistType is 'country'", () => {
      store.getState.mockReturnValue({
        countryRisks: { USA: ["High"], UK: ["Medium"] },
        industryRisks: {},
      });

      const result = getPicklist("country");
      expect(result).toEqual(new Map([
        ["USA", ["High"]],
        ["UK", ["Medium"]],
      ]));
    });

    it("should return industry risks if picklistType is 'industry'", () => {
      store.getState.mockReturnValue({
        countryRisks: {},
        industryRisks: { Tech: ["High"], Finance: ["Low"] },
      });

      const result = getPicklist("industry");
      expect(result).toEqual(new Map([
        ["Tech", ["High"]],
        ["Finance", ["Low"]],
      ]));
    });

    it("should return an empty map when no data is found", () => {
      store.getState.mockReturnValue({
        countryRisks: {},
        industryRisks: {},
      });

      const result = getPicklist("unknown");
      expect(result).toEqual(new Map());
    });
  });
});
============================================================
import { updateRiskItems, removeRiskItem, updateThresholdData, getExistingRiskData, getRiskTolerance } from "../riskDataUpdater";
import { updateMultiselectThresholds } from "../../actions";
import { store } from "../../store"; 

jest.mock("../../store", () => ({
  store: {
    getState: jest.fn(),
    dispatch: jest.fn(),
  },
}));

const mockRiskProvider = {
  getQuestionRiskData: jest.fn(),
  updateThresholdValues: jest.fn(),
  removeThresholdValue: jest.fn(),
};

jest.mock("../../riskProvider", () => mockRiskProvider);

describe("riskDataUpdater", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("updateRiskItems", () => {
    it("should not update when riskData is undefined", () => {
      mockRiskProvider.getQuestionRiskData.mockReturnValue(undefined);
      updateRiskItems({ option: "Test", percentage: 50 });
      expect(mockRiskProvider.updateThresholdValues).not.toHaveBeenCalled();
    });

    it("should not update when percentage is greater than 100", () => {
      mockRiskProvider.getQuestionRiskData.mockReturnValue({});
      updateRiskItems({ option: "Test", percentage: 110 });
      expect(mockRiskProvider.updateThresholdValues).not.toHaveBeenCalled();
    });

    it("should update thresholds correctly", () => {
      const mockRiskData = {};
      const mockThresholdResponse = { updated: true };
      mockRiskProvider.getQuestionRiskData.mockReturnValue(mockRiskData);
      mockRiskProvider.updateThresholdValues.mockReturnValue(mockThresholdResponse);

      updateRiskItems({ option: "Test", percentage: 50 });

      expect(mockRiskProvider.updateThresholdValues).toHaveBeenCalledWith(mockRiskData, expect.anything());
      expect(store.dispatch).toHaveBeenCalledWith(updateMultiselectThresholds(mockThresholdResponse));
    });
  });

  describe("removeRiskItem", () => {
    it("should not remove when riskData is undefined", () => {
      mockRiskProvider.getQuestionRiskData.mockReturnValue(undefined);
      removeRiskItem({ option: "Test", percentage: 50 });
      expect(mockRiskProvider.removeThresholdValue).not.toHaveBeenCalled();
    });

    it("should remove threshold value correctly", () => {
      const mockRiskData = {};
      const mockThresholdResponse = { updated: true };
      mockRiskProvider.getQuestionRiskData.mockReturnValue(mockRiskData);
      mockRiskProvider.removeThresholdValue.mockReturnValue(mockThresholdResponse);

      removeRiskItem({ option: "Test", percentage: 50 });

      expect(mockRiskProvider.removeThresholdValue).toHaveBeenCalledWith(mockRiskData, "Test", expect.anything());
      expect(store.dispatch).toHaveBeenCalledWith(updateMultiselectThresholds(mockThresholdResponse));
    });
  });

  describe("getExistingRiskData", () => {
    it("should return existing risk data", () => {
      const mockExistingData = { riskCategories: ["Category1"] };
      store.getState.mockReturnValue(mockExistingData);

      const result = getExistingRiskData();
      expect(result.riskCategories).toEqual(["Category1"]);
    });
  });

  describe("updateThresholdData", () => {
    it("should dispatch updated threshold data", () => {
      const mockResponse = { updatedData: "New Data" };
      updateThresholdData(mockResponse);
      expect(store.dispatch).toHaveBeenCalledWith(updateMultiselectThresholds(mockResponse));
    });
  });

  describe("getRiskTolerance", () => {
    it("should return risk tolerance from state", () => {
      store.getState.mockReturnValue({ riskTolerance: 80 });

      const result = getRiskTolerance();
      expect(result).toBe(80);
    });
  });
});
===================================================
import { render, screen } from "@testing-library/react";
import { describe, it, expect, vi } from "vitest";
import ThresholdListener from "path-to/ThresholdListener";
import { useStore } from "react-redux";

vi.mock("react-redux", () => ({
  useStore: vi.fn(),
}));

describe("ThresholdListener Component", () => {
  let mockDispatch: vi.Mock;

  beforeEach(() => {
    mockDispatch = vi.fn();
    (useStore as vi.Mock).mockReturnValue({ dispatch: mockDispatch });
  });

  it("should update previousData when fieldData changes", () => {
    const { rerender } = render(<ThresholdListener fieldData={{ test: 1 }} />);
    
    expect(mockDispatch).not.toHaveBeenCalled();
    
    rerender(<ThresholdListener fieldData={{ test: 2 }} />);
    
    // Ensure previousData updates (mock setPreviousData if needed)
  });

  it("should clear errors when showErrors is false", () => {
    const clearErrors = vi.fn();
    
    render(<ThresholdListener showErrors={false} clearErrors={clearErrors} fieldName="testField" />);
    
    expect(clearErrors).toHaveBeenCalledWith("testField");
  });

  it("should call setError when showErrors is true and errorMessage exists", () => {
    const setError = vi.fn();
    
    render(<ThresholdListener showErrors={true} errorMessage="Error!" setError={setError} fieldName="testField" />);
    
    expect(setError).toHaveBeenCalledWith("testField", { type: "custom", message: "Error!" });
  });

  it("should remove risk items and update visibility when not visible", () => {
    const removeRiskItem = vi.fn();
    
    render(<ThresholdListener isVisible={false} previousData={new Map([["option1", 50]])} removeRiskItem={removeRiskItem} />);
    
    expect(removeRiskItem).toHaveBeenCalledWith("option1", 50);
    expect(mockDispatch).toHaveBeenCalledWith(expect.objectContaining({ type: "changeFieldVisibilityRemoval" }));
  });

  it("should update risk items and setValue when visible", () => {
    const updateRiskItems = vi.fn();
    const setValue = vi.fn();

    render(<ThresholdListener isVisible={true} previousData={new Map([["option1", 50]])} updateRiskItems={updateRiskItems} setValue={setValue} fieldName="testField" />);
    
    expect(updateRiskItems).toHaveBeenCalledWith("option1", 50);
    expect(setValue).toHaveBeenCalledWith("testField", expect.any(Map));
  });
});

