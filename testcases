import { getUser Info } from './path/to/your/getUser Info'; // Adjust the import based on your structure
import { loggedInUser  } from '../../interfaces/ApiInterfaces';

describe('getUser Info', () => {
    beforeEach(() => {
        // Clear session storage before each test
        sessionStorage.clear();
    });

    it('should return user information when valid data is present in session storage', () => {
        const mockUser  = {
            firstName: 'John',
            lastName: 'Doe',
            guId: '12345',
        };

        // Set mock user data in session storage
        sessionStorage.setItem('userInfo', JSON.stringify(mockUser ));

        const expectedUser Info: loggedInUser  = {
            userName: 'John Doe',
            userBrid: '12345',
        };

        // Call the function and check the result
        const userInfo = getUser Info();
        expect(userInfo).toEqual(expectedUser Info);
    });

    it('should throw an error if user information is not found in session storage', () => {
        expect(() => getUser Info()).toThrow('Unable to find user information');
    });

    it('should throw an error if user information is incomplete', () => {
        const incompleteUser  = {
            firstName: 'Jane',
            lastName: '', // Missing last name
            guId: '67890',
        };

        // Set incomplete user data in session storage
        sessionStorage.setItem('userInfo', JSON.stringify(incompleteUser ));

        expect(() => getUser Info()).toThrow('Missing user information');
    });

    it('should throw an error if user information is missing fields', () => {
        const incompleteUser  = {
            firstName: 'Jane',
            // lastName is missing
            guId: '67890',
        };

        // Set incomplete user data in session storage
        sessionStorage.setItem('userInfo', JSON.stringify(incompleteUser ));

        expect(() => getUser Info()).toThrow('Missing user information');
    });
});
==================================================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import RiskScoreContainer from './RiskScoreContainer';
import { RiskScoreDisplay } from '../../../Generic/RiskScoreDisplay/RiskScoreDisplay'; // Adjust the import based on your structure
import { getRiskRating } from 'src/redux/selectors/riskDataSelectors'; // Adjust the import based on your structure

const mockStore = configureStore([]);

describe('RiskScoreContainer Component', () => {
    let store;

    beforeEach(() => {
        store = mockStore({
            riskScore: {
                overriddenRiskScore: 'High', // Example risk score
            },
        });
    });

    it('renders the RiskScoreDisplay with the correct risk rating', () => {
        render(
            <Provider store={store}>
                <RiskScoreContainer />
            </Provider>
        );

        // Check if the RiskScoreDisplay is rendered with the correct risk rating
        expect(screen.getByText(/Risk Attestation/i)).toBeInTheDocument();
        expect(screen.getByText(/High/i)).toBeInTheDocument(); // Check for the risk rating
    });

    it('renders an empty RiskScoreDisplay when overriddenRiskScore is not set', () => {
        store = mockStore({
            riskScore: {
                overriddenRiskScore: '', // No risk score
            },
        });

        render(
            <Provider store={store}>
                <RiskScoreContainer />
            </Provider>
        );

        // Check if the RiskScoreDisplay is rendered with an empty risk rating
        expect(screen.getByText(/Risk Attestation/i)).toBeInTheDocument();
        expect(screen.queryByText(/High/i)).not.toBeInTheDocument(); // Ensure 'High' is not present
        expect(screen.getByText(/''/i)).not.toBeInTheDocument(); // Adjust based on how you handle empty states
    });
});
=====================================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import RiskScoreContainer from './RiskScoreContainer';
import { RiskScoreDisplay } from './RiskScoreDisplay'; // Adjust the import based on your structure

const mockStore = configureStore([]);

describe('RiskScoreContainer Component', () => {
    let store;

    beforeEach(() => {
        store = mockStore({
            riskScore: {
                overriddenRiskScore: 'High', // Example risk score
            },
        });
    });

    it('renders the RiskScoreDisplay with the correct risk rating', () => {
        render(
            <Provider store={store}>
                <RiskScoreContainer />
            </Provider>
        );

        // Check if the RiskScoreDisplay is rendered with the correct risk rating
        expect(screen.getByText(/High/i)).toBeInTheDocument();
    });

    it('renders an empty RiskScoreDisplay when overriddenRiskScore is not set', () => {
        store = mockStore({
            riskScore: {
                overriddenRiskScore: '', // No risk score
            },
        });

        render(
            <Provider store={store}>
                <RiskScoreContainer />
            </Provider>
        );

        // Check if the RiskScoreDisplay is rendered with an empty risk rating
        expect(screen.getByText(/''/i)).not.toBeInTheDocument(); // Adjust based on how you handle empty states
    });
});

=================================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import ReviewAndAttest from './ReviewAndAttest';
import { useApiProvider } from './../../../hooks/useApiProvider';

// Mock the useApiProvider hook
jest.mock('./../../../hooks/useApiProvider', () => ({
    useApiProvider: jest.fn(),
}));

describe('ReviewAndAttest Component', () => {
    it('renders the Review & Attest button', () => {
        // Mock the apiProvider return value
        const mockReviewAndAttestData = jest.fn();
        useApiProvider.mockReturnValue({ reviewAndAttestData: mockReviewAndAttestData });

        render(<ReviewAndAttest />);

        // Check if the button is in the document
        const buttonElement = screen.getByText(/Review & Attest/i);
        expect(buttonElement).toBeInTheDocument();

        // Optionally, check if the button click calls the mock function
        buttonElement.click();
        expect(mockReviewAndAttestData).toHaveBeenCalled();
    });
});
------------------------------------------------------------------
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import ReviewAndAttest from './ReviewAndAttest';
import { useApiProvider } from './../../../hooks/useApiProvider';

// Mock the `useApiProvider` hook
jest.mock('./../../../hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(),
}));

describe('ReviewAndAttest Component', () => {
  const mockReviewAndAttestData = jest.fn();

  beforeEach(() => {
    (useApiProvider as jest.Mock).mockReturnValue({
      reviewAndAttestData: mockReviewAndAttestData,
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('renders the Panel component correctly', () => {
    render(<ReviewAndAttest />);
    const panel = screen.getByTestId('panel');
    expect(panel).toBeInTheDocument();
    expect(panel).toHaveStyle({ marginBottom: '0.75em' });
  });

  test('renders the Button with the correct props', () => {
    render(<ReviewAndAttest />);
    const button = screen.getByRole('button', { name: /review & attest/i });

    expect(button).toBeInTheDocument();
    expect(button).toHaveAttribute('variant', 'primary');
    expect(button).toHaveAttribute('mediaPosition', 'right');
  });

  test('renders the Icon inside the Button', () => {
    render(<ReviewAndAttest />);
    const icon = screen.getByTestId('icon'); // If your Icon component uses a `data-testid`
    expect(icon).toBeInTheDocument();
    expect(icon).toHaveAttribute('icon', 'document');
    expect(icon).toHaveAttribute('size', 'sm');
  });

  test('calls reviewAndAttestData on Button click', () => {
    render(<ReviewAndAttest />);
    const button = screen.getByRole('button', { name: /review & attest/i });

    fireEvent.click(button);

    // Verify the function was called
    expect(mockReviewAndAttestData).toHaveBeenCalledTimes(1);
  });
});

====================================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom'; // For additional matchers like 'toBeInTheDocument'
import ReviewAndAttest from './ReviewAndAttest';
import { useApiProvider } from './../../../hooks/useApiProvider';

// Mock the `useApiProvider` hook
jest.mock('./../../../hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(),
}));

describe('ReviewAndAttest Component', () => {
  const mockReviewAndAttestData = jest.fn();

  beforeEach(() => {
    (useApiProvider as jest.Mock).mockReturnValue({
      reviewAndAttestData: mockReviewAndAttestData,
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('renders the component correctly', () => {
    render(<ReviewAndAttest />);

    // Assert that the button is in the document
    const button = screen.getByRole('button', { name: /review & attest/i });
    expect(button).toBeInTheDocument();

    // Assert that the icon is rendered
    const icon = screen.getByTestId('icon'); // Assuming Icon has a `data-testid` or equivalent
    expect(icon).toBeInTheDocument();
  });

  test('button click calls the reviewAndAttestData function', () => {
    render(<ReviewAndAttest />);

    const button = screen.getByRole('button', { name: /review & attest/i });
    fireEvent.click(button);

    // Assert that the API function was called
    expect(mockReviewAndAttestData).toHaveBeenCalledTimes(1);
  });

  test('button has correct styling and properties', () => {
    render(<ReviewAndAttest />);

    const button = screen.getByRole('button', { name: /review & attest/i });

    // Assert button has the correct classes or attributes
    expect(button).toHaveClass('bp3-button'); // Adjust for Blueprint class
    expect(button).toHaveAttribute('variant', 'primary');
    expect(button).toHaveAttribute('mediaPosition', 'right');
  });
});

=======================================================================
<button
  data-testid="alert-dismiss-button"
  onClick={() => contentProvider?.updateFcrmAlerts(undefined)}
>
  Dismiss
</button>

=======================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    const dismissButton = screen.getByText('Dismiss');
    fireEvent.click(dismissButton);

    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  // Additional tests for completeness
  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });

  it('handles missing updateFcrmAlerts function gracefully', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: null,
    });

    render(<Alerts />);

    const dismissButton = screen.getByText('Dismiss');
    fireEvent.click(dismissButton);

    // No error should be thrown, but there's no function to call
    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
  });

  it('renders without crashing when useContentProvider fails', () => {
    useContentProvider.mockImplementation(() => {
      throw new Error('Failed to fetch content provider');
    });

    expect(() => render(<Alerts />)).not.toThrow();
  });

  it('renders default message when status is unknown', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'unknown',
        message: 'Unknown status!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Unknown:')).toBeInTheDocument();
    expect(screen.getByText('Unknown status!')).toBeInTheDocument();
  });

  it('has correct ARIA attributes for accessibility', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
    expect(screen.getByRole('alert')).toHaveAttribute('aria-live', 'assertive');
  });
});
=================================================================================

onDismiss={() => {
  console.log('onDismiss called'); // Debug log
  contentProvider?.updateFcrmAlerts(undefined);
}}



it('does not throw error if updateFcrmAlerts is not defined', () => {
  useContentProvider.mockReturnValue({
    fcrmAlert: {
      status: 'success',
      message: 'Operation successful',
    },
  });

  render(<Alerts />);
  const dismissButton = screen.getByRole('button', { name: /dismiss/i });

  // Simulate dismiss action
  expect(() => fireEvent.click(dismissButton)).not.toThrow();
});


it('matches snapshot for success state', () => {
  useContentProvider.mockReturnValue({
    fcrmAlert: {
      status: 'success',
      message: 'Operation successful',
    },
  });

  const { asFragment } = render(<Alerts />);
  expect(asFragment()).toMatchSnapshot();
});


======================================================
it('does not render Alert when contentProvider is null', () => {
  useContentProvider.mockReturnValue(null);

  const { container } = render(<Alerts />);
  expect(container.firstChild).toBeNull();
});

=============================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    const dismissButton = screen.getByRole('button', { name: /dismiss/i });
    fireEvent.click(dismissButton);

    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });
});

=============================================================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    fireEvent.click(screen.getByRole('button', { name: /dismiss/i }));
    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });
});



===================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts';
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });
});

======================================================================================================

import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts';
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
  });

  it('renders error status and message', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
  });
});
===============================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import Alerts from './alert'; // Adjust the import path as needed
import { useContentProvider } from '../../hooks/useContentProvider';

// Mock the `useContentProvider` hook
jest.mock('../../hooks/useContentProvider', () => ({
  useContentProvider: jest.fn(),
}));

describe('Alerts Component', () => {
  it('renders the Alert with success status and message', () => {
    // Mock data for the content provider
    const mockContentProvider = {
      fcrmAlert: {
        status: 'success',
        message: 'Operation completed successfully.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Check if the Alert is rendered with success status
    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation completed successfully.')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders the Alert with error status and message', () => {
    const mockContentProvider = {
      fcrmAlert: {
        status: 'error',
        message: 'There was an error processing your request.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Check if the Alert is rendered with error status
    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('There was an error processing your request.')).toBeInTheDocument();
  });

  it('calls onDismiss when the Alert is dismissed', () => {
    const mockContentProvider = {
      fcrmAlert: {
        status: 'success',
        message: 'Operation completed successfully.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Simulate the dismiss action
    const dismissButton = screen.getByRole('button');
    fireEvent.click(dismissButton);

    // Verify that `updateFcrmAlerts` was called
    expect(mockContentProvider.updateFcrmAlerts).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if fcrmAlert is undefined', () => {
    const mockContentProvider = {
      fcrmAlert: undefined,
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    const { container } = render(<Alerts />);

    // Check that nothing is rendered
    expect(container.firstChild).toBeNull();
  });
});

=========================================================================================
jest.mock('@barclays/clm-react-document', () => ({
  ...jest.requireActual('@barclays/clm-react-document'), // Include other actual exports
  ClmReactDocumentUploader: jest.fn((props) => (
    <div data-testid="mock-document-uploader">
      Mock Document Uploader
      <button onClick={props.onFilesUpload}>Upload Files</button>
    </div>
  )),
}));

jest.mock('./CLMUploadDocDetails', () => jest.fn(() => <div data-testid="mock-upload-details">Mock Upload Details</div>));
jest.mock('../../../Fcrm/hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(() => ({
    someMethod: jest.fn(),
  })),
}));
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import YourComponent from './YourComponent';

test('renders mock components correctly', () => {
  render(<YourComponent />);

  // Verify that the mocked `ClmReactDocumentUploader` is rendered
  expect(screen.getByTestId('mock-document-uploader')).toBeInTheDocument();

  // Verify that the mocked `CLMUploadDocDetails` is rendered
  expect(screen.getByTestId('mock-upload-details')).toBeInTheDocument();
});

test('calls onFilesUpload when upload button is clicked', () => {
  const onFilesUpload = jest.fn();

  render(
    <YourComponent
      ClmReactDocumentUploader={{
        onFilesUpload,
      }}
    />
  );

  const uploadButton = screen.getByText('Upload Files');
  fireEvent.click(uploadButton);

  expect(onFilesUpload).toHaveBeenCalledTimes(1);
});

====================================================================

jest.mock('@barclays/clm-react-docum', () => ({
  ClmReactDocumentUploader: jest.fn(() => <div>Mock Uploader</div>),
}));

jest.mock('./CLMUploadDocDetails', () => jest.fn(() => <div>Mock Upload Details</div>));

=====================================================================
const nxPreset = require("@nx/jest/preset");

module.exports = {
  ...nxPreset,
  testEnvironment: "jest-environment-jsdom",
  transform: {
    "^.+\\.[tj]sx?$": "babel-jest",
  },
};
=====================================================================
import React from "react";

const MyComponent: React.FC = () => {
  return <div>Hello, Jest!</div>;
};

export default MyComponent;

=====================================================================
import React from "react";
import { render, screen } from "@testing-library/react";
import MyComponent from "./MyComponent";

describe("MyComponent", () => {
  it("renders correctly", () => {
    render(<MyComponent />);
    expect(screen.getByText("Hello, Jest!")).toBeInTheDocument();
  });
});

================================================================================

npm install --save @nx/react react react-dom
npm install --save-dev @babel/core babel-jest @babel/preset-env @babel/preset-react @babel/preset-typescript jest ts-jest typescript

npm install --save-dev babel-jest @babel/core @babel/preset-env @babel/preset-react
npm install --save-dev @babel/preset-typescript
========================================================

import React from 'react';
import { render, fireEvent } from '@testing-library/react';
import { CLMSelect } from './CLMSelect';

describe('CLMSelect Component', () => {
  it('should render the options and call handleChange on selection', () => {
    // Manual mock function
    const mockHandleChange = (fieldName: string, value: any) => {
      console.log(`handleChange called with fieldName: ${fieldName}, value: ${value}`);
    };

    const mockConfig = {
      fieldName: 'selectField',
      fieldLabel: 'Select Option',
      fieldDescription: 'Choose an option',
      values: ['Option 1', 'Option 2', 'Option 3'],
    };

    const { getByLabelText, getByRole } = render(
      <CLMSelect
        componentConfig={mockConfig}
        section="test-section"
        handleChange={mockHandleChange}
        value="Option 1"
        readOnly={false}
      />
    );

    // Check if options are rendered
    expect(getByRole('option', { name: 'Option 1' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 2' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 3' })).toBeInTheDocument();

    // Simulate user selecting a new option
    fireEvent.change(getByLabelText('Select Option'), { target: { value: 'Option 2' } });

    // Output will be visible in the console
  });
});

===========================================================================
import React from 'react';
import { render, fireEvent } from '@testing-library/react';
import { CLMSelect } from './CLMSelect';

describe('CLMSelect Component', () => {
  it('should render the options and call handleChange on selection', () => {
    const mockHandleChange = jest.fn();

    const mockConfig = {
      fieldName: 'selectField',
      fieldLabel: 'Select Option',
      fieldDescription: 'Choose an option',
      values: ['Option 1', 'Option 2', 'Option 3'],
    };

    const { getByLabelText, getByRole } = render(
      <CLMSelect
        componentConfig={mockConfig}
        section="test-section"
        handleChange={mockHandleChange}
        value="Option 1"
        readOnly={false}
      />
    );

    // Check if options are rendered
    expect(getByRole('option', { name: 'Option 1' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 2' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 3' })).toBeInTheDocument();

    // Simulate user selecting a new option
    fireEvent.change(getByLabelText('Select Option'), { target: { value: 'Option 2' } });

    // Check if handleChange was called
    expect(mockHandleChange).toHaveBeenCalledWith('selectField', 'Option 2');
  });
});

=======================================================================================
{
  "name": "<your-project-name>",
  "targets": {
    "test": {
      "executor": "@nrwl/jest:jest",
      "options": {
        "jestConfig": "apps/<your-project-name>/jest.config.ts",
        "passWithNoTests": true
      },
      "outputs": ["coverage/apps/<your-project-name>"]
    }
  }
}

==========================================
const nxPreset = require('@nx/jest/preset').default;

module.exports = { ...nxPreset };

===============================================================

import { getJestProjects } from '@nx/jest';

export default {
  displayName: '<your-project-name>',
  preset: '../../jest.preset.js',
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
  globals: {},
  transform: {
    '^.+\\.[tj]sx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],
  coverageDirectory: '../../coverage/apps/<your-project-name>',
  testEnvironment: 'jsdom', // Use 'node' if not React-based
};

===============================================================


===============================================================
{
  "projects": {
    "clm-ui-fcrm": {
      "root": "apps/clm-ui-fcrm",
      "sourceRoot": "apps/clm-ui-fcrm/src",
      "projectType": "application",
      "targets": {
        "test": {
          "executor": "@nrwl/jest:jest",
          "outputs": ["coverage/apps/clm-ui-fcrm"],
          "options": {
            "jestConfig": "apps/clm-ui-fcrm/jest.config.ts",
            "passWithNoTests": true
          }
        }
      }
    }
  }
}

=========================================================================
import { Config } from '@jest/types';

// Sync object
const config: Config.InitialOptions = {
  setupFilesAfterEnv: ['./jest.setup.ts'], // Reference the setup file
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.tsx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
};

export default config;
=======================

import React from "react";
import { render, screen } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with the correct path to your component

// Default props for the test
const defaultProps = {
  componentConfig: {
    fieldName: "testDate",
    fieldLabel: "Test Date",
    description: "Select a date",
  },
  section: "Test Section",
  handleChange: jest.fn(),
  value: "2025-01-01",
  errorMessage: "",
  readOnly: false,
};

describe("CLMDate Component", () => {
  it("renders the label and input field", () => {
    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Assert: Check if the label is displayed
    expect(screen.getByText("Test Date")).toBeInTheDocument();

    // Assert: Check if the input field with the correct value is rendered
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeInTheDocument();
    expect(input).toHaveAttribute("type", "date");
  });
});




import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import CLMDate from './CLMDate'; // Adjust the import path based on your project structure

jest.mock('@barclays/blueprint-react', () => ({
  __esModule: true,  // This line indicates that the module is an ES module
  ...jest.requireActual('@barclays/blueprint-react'),
  Icon: () => <span>MockIcon</span>,  // Mock the Icon component
}));

const visibilityRule = { linkedFieldName: 'someField', linkedFieldValue: true };

const componentConfig = {
  fieldName: 'date',
  fieldLabel: 'Date',
  componentType: 'input',
  description: 'Select a date',
  values: ['2025-01-16'],
  isVisible: visibilityRule,
  isEditable: true,
  validation: 'required'
};

test('renders CLMDate component', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  const inputElement = screen.getByLabelText('Date');
  expect(inputElement).toBeInTheDocument();
});

test('calls handleChange on input change', () => {
  const handleChange = jest.fn();
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={handleChange} readOnly={false} />);
  const inputElement = screen.getByLabelText('Date');
  fireEvent.change(inputElement, { target: { value: '2025-01-16' } });
  expect(handleChange).toHaveBeenCalledWith('date', '2025-01-16');
});

test('displays error message', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} errorMessage="Invalid date" />);
  const errorElement = screen.getByText('Invalid date');
  expect(errorElement).toBeInTheDocument();
});

test('renders component as editable or read-only based on isEditable property', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  const editableInputElement = screen.getByLabelText('Date');
  expect(editableInputElement).not.toBeDisabled();

  const readOnlyConfig = { ...componentConfig, isEditable: false };
  render(<CLMDate componentConfig={readOnlyConfig} value="" handleChange={() => {}} readOnly={true} />);
  const readOnlyInputElement = screen.getByLabelText('Date');
  expect(readOnlyInputElement).toBeDisabled();
});

=============================================================================
jest.mock('@barclays/blueprint-react', () => {
  const originalModule = jest.requireActual('@barclays/blueprint-react');
  return {
    ...originalModule,
    Icon: ({ icon }) => <span data-testid={`icon-${icon}`}>{icon}</span>, // Mock icon rendering
  };
});

===========================================================================
{
  "targets": {
    "test": {
      "executor": "@nrwl/jest:jest",
      "options": {
        "jestConfig": "apps/your-app/jest.config.ts",
        "passWithNoTests": true
      },
      "outputs": ["coverage/apps/your-app"]
    }
  }
}
==================================================================
nx generate @nrwl/jest:configuration your-app-or-lib-name

==================================================================
import { getJestProjects } from '@nrwl/jest';

export default {
  projects: getJestProjects(),
};
===================================================================
/* jest.config.ts */
export default {
  displayName: 'your-app',
  preset: '../../jest.preset.js',
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.[tj]sx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],
  coverageDirectory: '../../coverage/apps/your-app',
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
};
==================================================================
import '@testing-library/jest-dom';

==================================================================
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with your actual file path
import { ICLMDate } from "./CLMDate.types"; // Replace with your actual interface path

describe("CLMDate Component", () => {
  const mockHandleChange = jest.fn();

  const defaultProps: ICLMDate = {
    componentConfig: {
      fieldName: "testDate",
      fieldLabel: "Test Date",
      description: "Select a date",
    },
    handleChange: mockHandleChange,
    value: "2025-01-01",
    errorMessage: "",
    readOnly: false,
  };

  it("renders the component correctly", () => {
    render(<CLMDate {...defaultProps} />);

    // Check if label is rendered
    expect(screen.getByText("Test Date")).toBeInTheDocument();
    // Check if description is rendered
    expect(screen.getByText("Select a date")).toBeInTheDocument();
    // Check if input is rendered
    const input = screen.getByRole("textbox");
    expect(input).toBeInTheDocument();
    expect(input).toHaveValue("2025-01-01");
  });

  it("calls handleChange when input value changes", () => {
    render(<CLMDate {...defaultProps} />);

    const input = screen.getByRole("textbox");
    fireEvent.change(input, { target: { value: "2025-02-01" } });

    expect(mockHandleChange).toHaveBeenCalledTimes(1);
    expect(mockHandleChange).toHaveBeenCalledWith("testDate", "2025-02-01");
  });

  it("displays an error message if provided", () => {
    render(
      <CLMDate
        {...defaultProps}
        errorMessage="This field is required"
      />
    );

    // Check if the error message is displayed
    expect(screen.getByText("This field is required")).toBeInTheDocument();
  });

  it("disables the input when readOnly is true", () => {
    render(
      <CLMDate
        {...defaultProps}
        readOnly={true}
      />
    );

    const input = screen.getByRole("textbox");
    expect(input).toBeDisabled();
  });

  it("renders the calendar icon", () => {
    render(<CLMDate {...defaultProps} />);

    const calendarIcon = screen.getByLabelText("calendar");
    expect(calendarIcon).toBeInTheDocument();
  });

  it("renders without crashing when section prop is provided", () => {
    render(<CLMDate {...defaultProps} section="Test Section" />);

    // Check if component renders properly with the section prop
    expect(screen.getByText("Test Date")).toBeInTheDocument();
  });
});
=================================================================================================
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with the correct file path
import { ICLMdate } from "./CLMDate.types"; // Replace with the correct file path

const defaultProps: ICLMdate = {
  componentConfig: {
    fieldName: "testDate",
    fieldLabel: "Test Date",
    description: "Select a date",
  },
  section: "General",
  handleChange: jest.fn(),
  value: "2025-01-01",
  errorMessage: "",
  readOnly: false,
};

describe("CLMDate Component", () => {
  it("renders the component with label, description, and input field", () => {
    render(<CLMDate {...defaultProps} />);

    // Check the label
    expect(screen.getByText("Test Date")).toBeInTheDocument();

    // Check the description
    expect(screen.getByText("Select a date")).toBeInTheDocument();

    // Check the input field
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeInTheDocument();
    expect(input).toHaveAttribute("type", "date");
  });

  it("calls handleChange when the input value changes", () => {
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const input = screen.getByDisplayValue("2025-01-01");

    // Simulate changing the input value
    fireEvent.change(input, { target: { value: "2025-02-01" } });

    // Check if handleChange was called with the correct arguments
    expect(defaultProps.handleChange).toHaveBeenCalledWith(
      "testDate",
      "2025-02-01"
    );
  });

  it("displays an error message when errorMessage prop is provided", () => {
    const propsWithError = {
      ...defaultProps,
      errorMessage: "Invalid date",
    };

    render(<CLMDate {...propsWithError} />);

    // Check if the error message is displayed
    expect(screen.getByText("Invalid date")).toBeInTheDocument();
  });

  it("renders a disabled input when readOnly is true", () => {
    const readOnlyProps = {
      ...defaultProps,
      readOnly: true,
    };

    render(<CLMDate {...readOnlyProps} />);

    // Check if the input is disabled
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeDisabled();
  });
});
===========================================================================================
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import { CLMDate } from './CLMDate';
import { ICLMdate } from './CLMDate.types';

describe('CLMDate Component', () => {
  it('should render the CLMDate component correctly', () => {
    // Mock handleChange function
    const mockHandleChange = jest.fn();

    // Default props for the component
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: mockHandleChange,
      value: '2024-01-01',
      errorMessage: '',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find elements in the component
    const inputElement = screen.getByRole('textbox');
    const labelElement = screen.getByText('Test Label');
    const descriptionElement = screen.getByText('Test Description');

    // Assertions: Input field, label, and description should be present
    expect(inputElement).toBeInTheDocument();
    expect(labelElement).toBeInTheDocument();
    expect(descriptionElement).toBeInTheDocument();

    // Assert input attributes
    expect(inputElement).toHaveAttribute('type', 'date');
    expect(inputElement).toHaveAttribute('value', '2024-01-01');
    expect(inputElement).not.toBeDisabled();
  });

  it('should call handleChange when input value changes', () => {
    // Mock handleChange function
    const mockHandleChange = jest.fn();

    // Default props
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: mockHandleChange,
      value: '2024-01-01',
      errorMessage: '',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const inputElement = screen.getByRole('textbox');

    // Simulate a change event
    fireEvent.change(inputElement, { target: { value: '2024-02-01' } });

    // Assert handleChange was called with correct arguments
    expect(mockHandleChange).toHaveBeenCalledWith('testField', '2024-02-01');
  });

  it('should render an error message if provided', () => {
    // Default props with an error message
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: jest.fn(),
      value: '2024-01-01',
      errorMessage: 'Invalid date',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the error message
    const errorElement = screen.getByText('Invalid date');

    // Assert the error message is rendered
    expect(errorElement).toBeInTheDocument();
  });

  it('should disable the input field if readOnly is true', () => {
    // Default props with readOnly set to true
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: jest.fn(),
      value: '2024-01-01',
      errorMessage: '',
      readOnly: true,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const inputElement = screen.getByRole('textbox');

    // Assert the input field is disabled
    expect(inputElement).toBeDisabled();
  });
})
=================================================================================
test('renders CLMDate component', () => {
  const componentConfig = { fieldName: 'date', fieldLabel: 'Date', description: 'Select a date' };
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  
  const inputElement = screen.getByLabelText('Date');
  expect(inputElement).toBeInTheDocument();
});



----------------------------------------------------------------
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import ReviewAndAttest from './ReviewAndAttest';
import { useApiProvider } from './../../../hooks/useApiProvider';

// Mock the `useApiProvider` hook
jest.mock('./../../../hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(),
}));

describe('ReviewAndAttest Component', () => {
  const mockReviewAndAttestData = jest.fn();

  beforeEach(() => {
    (useApiProvider as jest.Mock).mockReturnValue({
      reviewAndAttestData: mockReviewAndAttestData,
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('renders the Panel component correctly', () => {
    render(<ReviewAndAttest />);
    const panel = screen.getByTestId('panel');
    expect(panel).toBeInTheDocument();
    expect(panel).toHaveStyle({ marginBottom: '0.75em' });
  });

  test('renders the Button with the correct props', () => {
    render(<ReviewAndAttest />);
    const button = screen.getByRole('button', { name: /review & attest/i });

    expect(button).toBeInTheDocument();
    expect(button).toHaveAttribute('variant', 'primary');
    expect(button).toHaveAttribute('mediaPosition', 'right');
  });

  test('renders the Icon inside the Button', () => {
    render(<ReviewAndAttest />);
    const icon = screen.getByTestId('icon'); // If your Icon component uses a `data-testid`
    expect(icon).toBeInTheDocument();
    expect(icon).toHaveAttribute('icon', 'document');
    expect(icon).toHaveAttribute('size', 'sm');
  });

  test('calls reviewAndAttestData on Button click', () => {
    render(<ReviewAndAttest />);
    const button = screen.getByRole('button', { name: /review & attest/i });

    fireEvent.click(button);

    // Verify the function was called
    expect(mockReviewAndAttestData).toHaveBeenCalledTimes(1);
  });
});

====================================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom'; // For additional matchers like 'toBeInTheDocument'
import ReviewAndAttest from './ReviewAndAttest';
import { useApiProvider } from './../../../hooks/useApiProvider';

// Mock the `useApiProvider` hook
jest.mock('./../../../hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(),
}));

describe('ReviewAndAttest Component', () => {
  const mockReviewAndAttestData = jest.fn();

  beforeEach(() => {
    (useApiProvider as jest.Mock).mockReturnValue({
      reviewAndAttestData: mockReviewAndAttestData,
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('renders the component correctly', () => {
    render(<ReviewAndAttest />);

    // Assert that the button is in the document
    const button = screen.getByRole('button', { name: /review & attest/i });
    expect(button).toBeInTheDocument();

    // Assert that the icon is rendered
    const icon = screen.getByTestId('icon'); // Assuming Icon has a `data-testid` or equivalent
    expect(icon).toBeInTheDocument();
  });

  test('button click calls the reviewAndAttestData function', () => {
    render(<ReviewAndAttest />);

    const button = screen.getByRole('button', { name: /review & attest/i });
    fireEvent.click(button);

    // Assert that the API function was called
    expect(mockReviewAndAttestData).toHaveBeenCalledTimes(1);
  });

  test('button has correct styling and properties', () => {
    render(<ReviewAndAttest />);

    const button = screen.getByRole('button', { name: /review & attest/i });

    // Assert button has the correct classes or attributes
    expect(button).toHaveClass('bp3-button'); // Adjust for Blueprint class
    expect(button).toHaveAttribute('variant', 'primary');
    expect(button).toHaveAttribute('mediaPosition', 'right');
  });
});

=======================================================================
<button
  data-testid="alert-dismiss-button"
  onClick={() => contentProvider?.updateFcrmAlerts(undefined)}
>
  Dismiss
</button>

=======================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    const dismissButton = screen.getByText('Dismiss');
    fireEvent.click(dismissButton);

    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  // Additional tests for completeness
  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });

  it('handles missing updateFcrmAlerts function gracefully', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: null,
    });

    render(<Alerts />);

    const dismissButton = screen.getByText('Dismiss');
    fireEvent.click(dismissButton);

    // No error should be thrown, but there's no function to call
    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
  });

  it('renders without crashing when useContentProvider fails', () => {
    useContentProvider.mockImplementation(() => {
      throw new Error('Failed to fetch content provider');
    });

    expect(() => render(<Alerts />)).not.toThrow();
  });

  it('renders default message when status is unknown', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'unknown',
        message: 'Unknown status!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Unknown:')).toBeInTheDocument();
    expect(screen.getByText('Unknown status!')).toBeInTheDocument();
  });

  it('has correct ARIA attributes for accessibility', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
    expect(screen.getByRole('alert')).toHaveAttribute('aria-live', 'assertive');
  });
});
=================================================================================

onDismiss={() => {
  console.log('onDismiss called'); // Debug log
  contentProvider?.updateFcrmAlerts(undefined);
}}



it('does not throw error if updateFcrmAlerts is not defined', () => {
  useContentProvider.mockReturnValue({
    fcrmAlert: {
      status: 'success',
      message: 'Operation successful',
    },
  });

  render(<Alerts />);
  const dismissButton = screen.getByRole('button', { name: /dismiss/i });

  // Simulate dismiss action
  expect(() => fireEvent.click(dismissButton)).not.toThrow();
});


it('matches snapshot for success state', () => {
  useContentProvider.mockReturnValue({
    fcrmAlert: {
      status: 'success',
      message: 'Operation successful',
    },
  });

  const { asFragment } = render(<Alerts />);
  expect(asFragment()).toMatchSnapshot();
});


======================================================
it('does not render Alert when contentProvider is null', () => {
  useContentProvider.mockReturnValue(null);

  const { container } = render(<Alerts />);
  expect(container.firstChild).toBeNull();
});

=============================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    const dismissButton = screen.getByRole('button', { name: /dismiss/i });
    fireEvent.click(dismissButton);

    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });
});

=============================================================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    fireEvent.click(screen.getByRole('button', { name: /dismiss/i }));
    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });
});



===================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts';
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });
});

======================================================================================================

import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts';
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
  });

  it('renders error status and message', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
  });
});
===============================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import Alerts from './alert'; // Adjust the import path as needed
import { useContentProvider } from '../../hooks/useContentProvider';

// Mock the `useContentProvider` hook
jest.mock('../../hooks/useContentProvider', () => ({
  useContentProvider: jest.fn(),
}));

describe('Alerts Component', () => {
  it('renders the Alert with success status and message', () => {
    // Mock data for the content provider
    const mockContentProvider = {
      fcrmAlert: {
        status: 'success',
        message: 'Operation completed successfully.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Check if the Alert is rendered with success status
    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation completed successfully.')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders the Alert with error status and message', () => {
    const mockContentProvider = {
      fcrmAlert: {
        status: 'error',
        message: 'There was an error processing your request.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Check if the Alert is rendered with error status
    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('There was an error processing your request.')).toBeInTheDocument();
  });

  it('calls onDismiss when the Alert is dismissed', () => {
    const mockContentProvider = {
      fcrmAlert: {
        status: 'success',
        message: 'Operation completed successfully.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Simulate the dismiss action
    const dismissButton = screen.getByRole('button');
    fireEvent.click(dismissButton);

    // Verify that `updateFcrmAlerts` was called
    expect(mockContentProvider.updateFcrmAlerts).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if fcrmAlert is undefined', () => {
    const mockContentProvider = {
      fcrmAlert: undefined,
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    const { container } = render(<Alerts />);

    // Check that nothing is rendered
    expect(container.firstChild).toBeNull();
  });
});

=========================================================================================
jest.mock('@barclays/clm-react-document', () => ({
  ...jest.requireActual('@barclays/clm-react-document'), // Include other actual exports
  ClmReactDocumentUploader: jest.fn((props) => (
    <div data-testid="mock-document-uploader">
      Mock Document Uploader
      <button onClick={props.onFilesUpload}>Upload Files</button>
    </div>
  )),
}));

jest.mock('./CLMUploadDocDetails', () => jest.fn(() => <div data-testid="mock-upload-details">Mock Upload Details</div>));
jest.mock('../../../Fcrm/hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(() => ({
    someMethod: jest.fn(),
  })),
}));
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import YourComponent from './YourComponent';

test('renders mock components correctly', () => {
  render(<YourComponent />);

  // Verify that the mocked `ClmReactDocumentUploader` is rendered
  expect(screen.getByTestId('mock-document-uploader')).toBeInTheDocument();

  // Verify that the mocked `CLMUploadDocDetails` is rendered
  expect(screen.getByTestId('mock-upload-details')).toBeInTheDocument();
});

test('calls onFilesUpload when upload button is clicked', () => {
  const onFilesUpload = jest.fn();

  render(
    <YourComponent
      ClmReactDocumentUploader={{
        onFilesUpload,
      }}
    />
  );

  const uploadButton = screen.getByText('Upload Files');
  fireEvent.click(uploadButton);

  expect(onFilesUpload).toHaveBeenCalledTimes(1);
});

====================================================================

jest.mock('@barclays/clm-react-docum', () => ({
  ClmReactDocumentUploader: jest.fn(() => <div>Mock Uploader</div>),
}));

jest.mock('./CLMUploadDocDetails', () => jest.fn(() => <div>Mock Upload Details</div>));

=====================================================================
const nxPreset = require("@nx/jest/preset");

module.exports = {
  ...nxPreset,
  testEnvironment: "jest-environment-jsdom",
  transform: {
    "^.+\\.[tj]sx?$": "babel-jest",
  },
};
=====================================================================
import React from "react";

const MyComponent: React.FC = () => {
  return <div>Hello, Jest!</div>;
};

export default MyComponent;

=====================================================================
import React from "react";
import { render, screen } from "@testing-library/react";
import MyComponent from "./MyComponent";

describe("MyComponent", () => {
  it("renders correctly", () => {
    render(<MyComponent />);
    expect(screen.getByText("Hello, Jest!")).toBeInTheDocument();
  });
});

================================================================================

npm install --save @nx/react react react-dom
npm install --save-dev @babel/core babel-jest @babel/preset-env @babel/preset-react @babel/preset-typescript jest ts-jest typescript

npm install --save-dev babel-jest @babel/core @babel/preset-env @babel/preset-react
npm install --save-dev @babel/preset-typescript
========================================================

import React from 'react';
import { render, fireEvent } from '@testing-library/react';
import { CLMSelect } from './CLMSelect';

describe('CLMSelect Component', () => {
  it('should render the options and call handleChange on selection', () => {
    // Manual mock function
    const mockHandleChange = (fieldName: string, value: any) => {
      console.log(`handleChange called with fieldName: ${fieldName}, value: ${value}`);
    };

    const mockConfig = {
      fieldName: 'selectField',
      fieldLabel: 'Select Option',
      fieldDescription: 'Choose an option',
      values: ['Option 1', 'Option 2', 'Option 3'],
    };

    const { getByLabelText, getByRole } = render(
      <CLMSelect
        componentConfig={mockConfig}
        section="test-section"
        handleChange={mockHandleChange}
        value="Option 1"
        readOnly={false}
      />
    );

    // Check if options are rendered
    expect(getByRole('option', { name: 'Option 1' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 2' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 3' })).toBeInTheDocument();

    // Simulate user selecting a new option
    fireEvent.change(getByLabelText('Select Option'), { target: { value: 'Option 2' } });

    // Output will be visible in the console
  });
});

===========================================================================
import React from 'react';
import { render, fireEvent } from '@testing-library/react';
import { CLMSelect } from './CLMSelect';

describe('CLMSelect Component', () => {
  it('should render the options and call handleChange on selection', () => {
    const mockHandleChange = jest.fn();

    const mockConfig = {
      fieldName: 'selectField',
      fieldLabel: 'Select Option',
      fieldDescription: 'Choose an option',
      values: ['Option 1', 'Option 2', 'Option 3'],
    };

    const { getByLabelText, getByRole } = render(
      <CLMSelect
        componentConfig={mockConfig}
        section="test-section"
        handleChange={mockHandleChange}
        value="Option 1"
        readOnly={false}
      />
    );

    // Check if options are rendered
    expect(getByRole('option', { name: 'Option 1' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 2' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 3' })).toBeInTheDocument();

    // Simulate user selecting a new option
    fireEvent.change(getByLabelText('Select Option'), { target: { value: 'Option 2' } });

    // Check if handleChange was called
    expect(mockHandleChange).toHaveBeenCalledWith('selectField', 'Option 2');
  });
});

=======================================================================================
{
  "name": "<your-project-name>",
  "targets": {
    "test": {
      "executor": "@nrwl/jest:jest",
      "options": {
        "jestConfig": "apps/<your-project-name>/jest.config.ts",
        "passWithNoTests": true
      },
      "outputs": ["coverage/apps/<your-project-name>"]
    }
  }
}

==========================================
const nxPreset = require('@nx/jest/preset').default;

module.exports = { ...nxPreset };

===============================================================

import { getJestProjects } from '@nx/jest';

export default {
  displayName: '<your-project-name>',
  preset: '../../jest.preset.js',
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
  globals: {},
  transform: {
    '^.+\\.[tj]sx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],
  coverageDirectory: '../../coverage/apps/<your-project-name>',
  testEnvironment: 'jsdom', // Use 'node' if not React-based
};

===============================================================


===============================================================
{
  "projects": {
    "clm-ui-fcrm": {
      "root": "apps/clm-ui-fcrm",
      "sourceRoot": "apps/clm-ui-fcrm/src",
      "projectType": "application",
      "targets": {
        "test": {
          "executor": "@nrwl/jest:jest",
          "outputs": ["coverage/apps/clm-ui-fcrm"],
          "options": {
            "jestConfig": "apps/clm-ui-fcrm/jest.config.ts",
            "passWithNoTests": true
          }
        }
      }
    }
  }
}

=========================================================================
import { Config } from '@jest/types';

// Sync object
const config: Config.InitialOptions = {
  setupFilesAfterEnv: ['./jest.setup.ts'], // Reference the setup file
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.tsx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
};

export default config;
=======================

import React from "react";
import { render, screen } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with the correct path to your component

// Default props for the test
const defaultProps = {
  componentConfig: {
    fieldName: "testDate",
    fieldLabel: "Test Date",
    description: "Select a date",
  },
  section: "Test Section",
  handleChange: jest.fn(),
  value: "2025-01-01",
  errorMessage: "",
  readOnly: false,
};

describe("CLMDate Component", () => {
  it("renders the label and input field", () => {
    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Assert: Check if the label is displayed
    expect(screen.getByText("Test Date")).toBeInTheDocument();

    // Assert: Check if the input field with the correct value is rendered
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeInTheDocument();
    expect(input).toHaveAttribute("type", "date");
  });
});




import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import CLMDate from './CLMDate'; // Adjust the import path based on your project structure

jest.mock('@barclays/blueprint-react', () => ({
  __esModule: true,  // This line indicates that the module is an ES module
  ...jest.requireActual('@barclays/blueprint-react'),
  Icon: () => <span>MockIcon</span>,  // Mock the Icon component
}));

const visibilityRule = { linkedFieldName: 'someField', linkedFieldValue: true };

const componentConfig = {
  fieldName: 'date',
  fieldLabel: 'Date',
  componentType: 'input',
  description: 'Select a date',
  values: ['2025-01-16'],
  isVisible: visibilityRule,
  isEditable: true,
  validation: 'required'
};

test('renders CLMDate component', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  const inputElement = screen.getByLabelText('Date');
  expect(inputElement).toBeInTheDocument();
});

test('calls handleChange on input change', () => {
  const handleChange = jest.fn();
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={handleChange} readOnly={false} />);
  const inputElement = screen.getByLabelText('Date');
  fireEvent.change(inputElement, { target: { value: '2025-01-16' } });
  expect(handleChange).toHaveBeenCalledWith('date', '2025-01-16');
});

test('displays error message', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} errorMessage="Invalid date" />);
  const errorElement = screen.getByText('Invalid date');
  expect(errorElement).toBeInTheDocument();
});

test('renders component as editable or read-only based on isEditable property', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  const editableInputElement = screen.getByLabelText('Date');
  expect(editableInputElement).not.toBeDisabled();

  const readOnlyConfig = { ...componentConfig, isEditable: false };
  render(<CLMDate componentConfig={readOnlyConfig} value="" handleChange={() => {}} readOnly={true} />);
  const readOnlyInputElement = screen.getByLabelText('Date');
  expect(readOnlyInputElement).toBeDisabled();
});

=============================================================================
jest.mock('@barclays/blueprint-react', () => {
  const originalModule = jest.requireActual('@barclays/blueprint-react');
  return {
    ...originalModule,
    Icon: ({ icon }) => <span data-testid={`icon-${icon}`}>{icon}</span>, // Mock icon rendering
  };
});

===========================================================================
{
  "targets": {
    "test": {
      "executor": "@nrwl/jest:jest",
      "options": {
        "jestConfig": "apps/your-app/jest.config.ts",
        "passWithNoTests": true
      },
      "outputs": ["coverage/apps/your-app"]
    }
  }
}
==================================================================
nx generate @nrwl/jest:configuration your-app-or-lib-name

==================================================================
import { getJestProjects } from '@nrwl/jest';

export default {
  projects: getJestProjects(),
};
===================================================================
/* jest.config.ts */
export default {
  displayName: 'your-app',
  preset: '../../jest.preset.js',
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.[tj]sx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],
  coverageDirectory: '../../coverage/apps/your-app',
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
};
==================================================================
import '@testing-library/jest-dom';

==================================================================
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with your actual file path
import { ICLMDate } from "./CLMDate.types"; // Replace with your actual interface path

describe("CLMDate Component", () => {
  const mockHandleChange = jest.fn();

  const defaultProps: ICLMDate = {
    componentConfig: {
      fieldName: "testDate",
      fieldLabel: "Test Date",
      description: "Select a date",
    },
    handleChange: mockHandleChange,
    value: "2025-01-01",
    errorMessage: "",
    readOnly: false,
  };

  it("renders the component correctly", () => {
    render(<CLMDate {...defaultProps} />);

    // Check if label is rendered
    expect(screen.getByText("Test Date")).toBeInTheDocument();
    // Check if description is rendered
    expect(screen.getByText("Select a date")).toBeInTheDocument();
    // Check if input is rendered
    const input = screen.getByRole("textbox");
    expect(input).toBeInTheDocument();
    expect(input).toHaveValue("2025-01-01");
  });

  it("calls handleChange when input value changes", () => {
    render(<CLMDate {...defaultProps} />);

    const input = screen.getByRole("textbox");
    fireEvent.change(input, { target: { value: "2025-02-01" } });

    expect(mockHandleChange).toHaveBeenCalledTimes(1);
    expect(mockHandleChange).toHaveBeenCalledWith("testDate", "2025-02-01");
  });

  it("displays an error message if provided", () => {
    render(
      <CLMDate
        {...defaultProps}
        errorMessage="This field is required"
      />
    );

    // Check if the error message is displayed
    expect(screen.getByText("This field is required")).toBeInTheDocument();
  });

  it("disables the input when readOnly is true", () => {
    render(
      <CLMDate
        {...defaultProps}
        readOnly={true}
      />
    );

    const input = screen.getByRole("textbox");
    expect(input).toBeDisabled();
  });

  it("renders the calendar icon", () => {
    render(<CLMDate {...defaultProps} />);

    const calendarIcon = screen.getByLabelText("calendar");
    expect(calendarIcon).toBeInTheDocument();
  });

  it("renders without crashing when section prop is provided", () => {
    render(<CLMDate {...defaultProps} section="Test Section" />);

    // Check if component renders properly with the section prop
    expect(screen.getByText("Test Date")).toBeInTheDocument();
  });
});
=================================================================================================
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with the correct file path
import { ICLMdate } from "./CLMDate.types"; // Replace with the correct file path

const defaultProps: ICLMdate = {
  componentConfig: {
    fieldName: "testDate",
    fieldLabel: "Test Date",
    description: "Select a date",
  },
  section: "General",
  handleChange: jest.fn(),
  value: "2025-01-01",
  errorMessage: "",
  readOnly: false,
};

describe("CLMDate Component", () => {
  it("renders the component with label, description, and input field", () => {
    render(<CLMDate {...defaultProps} />);

    // Check the label
    expect(screen.getByText("Test Date")).toBeInTheDocument();

    // Check the description
    expect(screen.getByText("Select a date")).toBeInTheDocument();

    // Check the input field
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeInTheDocument();
    expect(input).toHaveAttribute("type", "date");
  });

  it("calls handleChange when the input value changes", () => {
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const input = screen.getByDisplayValue("2025-01-01");

    // Simulate changing the input value
    fireEvent.change(input, { target: { value: "2025-02-01" } });

    // Check if handleChange was called with the correct arguments
    expect(defaultProps.handleChange).toHaveBeenCalledWith(
      "testDate",
      "2025-02-01"
    );
  });

  it("displays an error message when errorMessage prop is provided", () => {
    const propsWithError = {
      ...defaultProps,
      errorMessage: "Invalid date",
    };

    render(<CLMDate {...propsWithError} />);

    // Check if the error message is displayed
    expect(screen.getByText("Invalid date")).toBeInTheDocument();
  });

  it("renders a disabled input when readOnly is true", () => {
    const readOnlyProps = {
      ...defaultProps,
      readOnly: true,
    };

    render(<CLMDate {...readOnlyProps} />);

    // Check if the input is disabled
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeDisabled();
  });
});
===========================================================================================
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import { CLMDate } from './CLMDate';
import { ICLMdate } from './CLMDate.types';

describe('CLMDate Component', () => {
  it('should render the CLMDate component correctly', () => {
    // Mock handleChange function
    const mockHandleChange = jest.fn();

    // Default props for the component
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: mockHandleChange,
      value: '2024-01-01',
      errorMessage: '',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find elements in the component
    const inputElement = screen.getByRole('textbox');
    const labelElement = screen.getByText('Test Label');
    const descriptionElement = screen.getByText('Test Description');

    // Assertions: Input field, label, and description should be present
    expect(inputElement).toBeInTheDocument();
    expect(labelElement).toBeInTheDocument();
    expect(descriptionElement).toBeInTheDocument();

    // Assert input attributes
    expect(inputElement).toHaveAttribute('type', 'date');
    expect(inputElement).toHaveAttribute('value', '2024-01-01');
    expect(inputElement).not.toBeDisabled();
  });

  it('should call handleChange when input value changes', () => {
    // Mock handleChange function
    const mockHandleChange = jest.fn();

    // Default props
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: mockHandleChange,
      value: '2024-01-01',
      errorMessage: '',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const inputElement = screen.getByRole('textbox');

    // Simulate a change event
    fireEvent.change(inputElement, { target: { value: '2024-02-01' } });

    // Assert handleChange was called with correct arguments
    expect(mockHandleChange).toHaveBeenCalledWith('testField', '2024-02-01');
  });

  it('should render an error message if provided', () => {
    // Default props with an error message
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: jest.fn(),
      value: '2024-01-01',
      errorMessage: 'Invalid date',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the error message
    const errorElement = screen.getByText('Invalid date');

    // Assert the error message is rendered
    expect(errorElement).toBeInTheDocument();
  });

  it('should disable the input field if readOnly is true', () => {
    // Default props with readOnly set to true
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: jest.fn(),
      value: '2024-01-01',
      errorMessage: '',
      readOnly: true,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const inputElement = screen.getByRole('textbox');

    // Assert the input field is disabled
    expect(inputElement).toBeDisabled();
  });
})
=================================================================================
test('renders CLMDate component', () => {
  const componentConfig = { fieldName: 'date', fieldLabel: 'Date', description: 'Select a date' };
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  
  const inputElement = screen.getByLabelText('Date');
  expect(inputElement).toBeInTheDocument();
});



---------------------------------------------------------------
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import ReviewAndAttest from './ReviewAndAttest';
import { useApiProvider } from './../../../hooks/useApiProvider';

// Mock the `useApiProvider` hook
jest.mock('./../../../hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(),
}));

describe('ReviewAndAttest Component', () => {
  const mockReviewAndAttestData = jest.fn();

  beforeEach(() => {
    (useApiProvider as jest.Mock).mockReturnValue({
      reviewAndAttestData: mockReviewAndAttestData,
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('renders the Panel component correctly', () => {
    render(<ReviewAndAttest />);
    const panel = screen.getByTestId('panel');
    expect(panel).toBeInTheDocument();
    expect(panel).toHaveStyle({ marginBottom: '0.75em' });
  });

  test('renders the Button with the correct props', () => {
    render(<ReviewAndAttest />);
    const button = screen.getByRole('button', { name: /review & attest/i });

    expect(button).toBeInTheDocument();
    expect(button).toHaveAttribute('variant', 'primary');
    expect(button).toHaveAttribute('mediaPosition', 'right');
  });

  test('renders the Icon inside the Button', () => {
    render(<ReviewAndAttest />);
    const icon = screen.getByTestId('icon'); // If your Icon component uses a `data-testid`
    expect(icon).toBeInTheDocument();
    expect(icon).toHaveAttribute('icon', 'document');
    expect(icon).toHaveAttribute('size', 'sm');
  });

  test('calls reviewAndAttestData on Button click', () => {
    render(<ReviewAndAttest />);
    const button = screen.getByRole('button', { name: /review & attest/i });

    fireEvent.click(button);

    // Verify the function was called
    expect(mockReviewAndAttestData).toHaveBeenCalledTimes(1);
  });
});

====================================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom'; // For additional matchers like 'toBeInTheDocument'
import ReviewAndAttest from './ReviewAndAttest';
import { useApiProvider } from './../../../hooks/useApiProvider';

// Mock the `useApiProvider` hook
jest.mock('./../../../hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(),
}));

describe('ReviewAndAttest Component', () => {
  const mockReviewAndAttestData = jest.fn();

  beforeEach(() => {
    (useApiProvider as jest.Mock).mockReturnValue({
      reviewAndAttestData: mockReviewAndAttestData,
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  test('renders the component correctly', () => {
    render(<ReviewAndAttest />);

    // Assert that the button is in the document
    const button = screen.getByRole('button', { name: /review & attest/i });
    expect(button).toBeInTheDocument();

    // Assert that the icon is rendered
    const icon = screen.getByTestId('icon'); // Assuming Icon has a `data-testid` or equivalent
    expect(icon).toBeInTheDocument();
  });

  test('button click calls the reviewAndAttestData function', () => {
    render(<ReviewAndAttest />);

    const button = screen.getByRole('button', { name: /review & attest/i });
    fireEvent.click(button);

    // Assert that the API function was called
    expect(mockReviewAndAttestData).toHaveBeenCalledTimes(1);
  });

  test('button has correct styling and properties', () => {
    render(<ReviewAndAttest />);

    const button = screen.getByRole('button', { name: /review & attest/i });

    // Assert button has the correct classes or attributes
    expect(button).toHaveClass('bp3-button'); // Adjust for Blueprint class
    expect(button).toHaveAttribute('variant', 'primary');
    expect(button).toHaveAttribute('mediaPosition', 'right');
  });
});

=======================================================================
<button
  data-testid="alert-dismiss-button"
  onClick={() => contentProvider?.updateFcrmAlerts(undefined)}
>
  Dismiss
</button>

=======================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    const dismissButton = screen.getByText('Dismiss');
    fireEvent.click(dismissButton);

    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  // Additional tests for completeness
  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });

  it('handles missing updateFcrmAlerts function gracefully', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: null,
    });

    render(<Alerts />);

    const dismissButton = screen.getByText('Dismiss');
    fireEvent.click(dismissButton);

    // No error should be thrown, but there's no function to call
    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
  });

  it('renders without crashing when useContentProvider fails', () => {
    useContentProvider.mockImplementation(() => {
      throw new Error('Failed to fetch content provider');
    });

    expect(() => render(<Alerts />)).not.toThrow();
  });

  it('renders default message when status is unknown', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'unknown',
        message: 'Unknown status!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Unknown:')).toBeInTheDocument();
    expect(screen.getByText('Unknown status!')).toBeInTheDocument();
  });

  it('has correct ARIA attributes for accessibility', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
    expect(screen.getByRole('alert')).toHaveAttribute('aria-live', 'assertive');
  });
});
=================================================================================

onDismiss={() => {
  console.log('onDismiss called'); // Debug log
  contentProvider?.updateFcrmAlerts(undefined);
}}



it('does not throw error if updateFcrmAlerts is not defined', () => {
  useContentProvider.mockReturnValue({
    fcrmAlert: {
      status: 'success',
      message: 'Operation successful',
    },
  });

  render(<Alerts />);
  const dismissButton = screen.getByRole('button', { name: /dismiss/i });

  // Simulate dismiss action
  expect(() => fireEvent.click(dismissButton)).not.toThrow();
});


it('matches snapshot for success state', () => {
  useContentProvider.mockReturnValue({
    fcrmAlert: {
      status: 'success',
      message: 'Operation successful',
    },
  });

  const { asFragment } = render(<Alerts />);
  expect(asFragment()).toMatchSnapshot();
});


======================================================
it('does not render Alert when contentProvider is null', () => {
  useContentProvider.mockReturnValue(null);

  const { container } = render(<Alerts />);
  expect(container.firstChild).toBeNull();
});

=============================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    const dismissButton = screen.getByRole('button', { name: /dismiss/i });
    fireEvent.click(dismissButton);

    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });
});

=============================================================================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts'; // Ensure the path is correct
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });

  it('calls onDismiss when the dismiss button is clicked', () => {
    const updateFcrmAlertsMock = jest.fn();
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: updateFcrmAlertsMock,
    });

    render(<Alerts />);

    fireEvent.click(screen.getByRole('button', { name: /dismiss/i }));
    expect(updateFcrmAlertsMock).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if there is no fcrmAlert', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: null,
      updateFcrmAlerts: jest.fn(),
    });

    const { container } = render(<Alerts />);
    expect(container.firstChild).toBeNull();
  });
});



===================================================
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts';
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message with success icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders error status and message with error icon', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
    expect(screen.getByLabelText('error icon label')).toBeInTheDocument();
  });
});

======================================================================================================

import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import Alerts from './Alerts';
import { useContentProvider } from '../../hooks/useContentProvider';

jest.mock('../../hooks/useContentProvider');

describe('Alerts Component', () => {
  it('renders success status and message', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'success',
        message: 'Operation successful!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation successful!')).toBeInTheDocument();
  });

  it('renders error status and message', () => {
    useContentProvider.mockReturnValue({
      fcrmAlert: {
        status: 'error',
        message: 'Operation failed!',
      },
      updateFcrmAlerts: jest.fn(),
    });

    render(<Alerts />);

    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('Operation failed!')).toBeInTheDocument();
  });
});
===============================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import Alerts from './alert'; // Adjust the import path as needed
import { useContentProvider } from '../../hooks/useContentProvider';

// Mock the `useContentProvider` hook
jest.mock('../../hooks/useContentProvider', () => ({
  useContentProvider: jest.fn(),
}));

describe('Alerts Component', () => {
  it('renders the Alert with success status and message', () => {
    // Mock data for the content provider
    const mockContentProvider = {
      fcrmAlert: {
        status: 'success',
        message: 'Operation completed successfully.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Check if the Alert is rendered with success status
    expect(screen.getByText('Success:')).toBeInTheDocument();
    expect(screen.getByText('Operation completed successfully.')).toBeInTheDocument();
    expect(screen.getByLabelText('success icon label')).toBeInTheDocument();
  });

  it('renders the Alert with error status and message', () => {
    const mockContentProvider = {
      fcrmAlert: {
        status: 'error',
        message: 'There was an error processing your request.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Check if the Alert is rendered with error status
    expect(screen.getByText('Error:')).toBeInTheDocument();
    expect(screen.getByText('There was an error processing your request.')).toBeInTheDocument();
  });

  it('calls onDismiss when the Alert is dismissed', () => {
    const mockContentProvider = {
      fcrmAlert: {
        status: 'success',
        message: 'Operation completed successfully.',
      },
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    render(<Alerts />);

    // Simulate the dismiss action
    const dismissButton = screen.getByRole('button');
    fireEvent.click(dismissButton);

    // Verify that `updateFcrmAlerts` was called
    expect(mockContentProvider.updateFcrmAlerts).toHaveBeenCalledWith(undefined);
  });

  it('does not render anything if fcrmAlert is undefined', () => {
    const mockContentProvider = {
      fcrmAlert: undefined,
      updateFcrmAlerts: jest.fn(),
    };
    (useContentProvider as jest.Mock).mockReturnValue(mockContentProvider);

    const { container } = render(<Alerts />);

    // Check that nothing is rendered
    expect(container.firstChild).toBeNull();
  });
});

=========================================================================================
jest.mock('@barclays/clm-react-document', () => ({
  ...jest.requireActual('@barclays/clm-react-document'), // Include other actual exports
  ClmReactDocumentUploader: jest.fn((props) => (
    <div data-testid="mock-document-uploader">
      Mock Document Uploader
      <button onClick={props.onFilesUpload}>Upload Files</button>
    </div>
  )),
}));

jest.mock('./CLMUploadDocDetails', () => jest.fn(() => <div data-testid="mock-upload-details">Mock Upload Details</div>));
jest.mock('../../../Fcrm/hooks/useApiProvider', () => ({
  useApiProvider: jest.fn(() => ({
    someMethod: jest.fn(),
  })),
}));
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import YourComponent from './YourComponent';

test('renders mock components correctly', () => {
  render(<YourComponent />);

  // Verify that the mocked `ClmReactDocumentUploader` is rendered
  expect(screen.getByTestId('mock-document-uploader')).toBeInTheDocument();

  // Verify that the mocked `CLMUploadDocDetails` is rendered
  expect(screen.getByTestId('mock-upload-details')).toBeInTheDocument();
});

test('calls onFilesUpload when upload button is clicked', () => {
  const onFilesUpload = jest.fn();

  render(
    <YourComponent
      ClmReactDocumentUploader={{
        onFilesUpload,
      }}
    />
  );

  const uploadButton = screen.getByText('Upload Files');
  fireEvent.click(uploadButton);

  expect(onFilesUpload).toHaveBeenCalledTimes(1);
});

====================================================================

jest.mock('@barclays/clm-react-docum', () => ({
  ClmReactDocumentUploader: jest.fn(() => <div>Mock Uploader</div>),
}));

jest.mock('./CLMUploadDocDetails', () => jest.fn(() => <div>Mock Upload Details</div>));

=====================================================================
const nxPreset = require("@nx/jest/preset");

module.exports = {
  ...nxPreset,
  testEnvironment: "jest-environment-jsdom",
  transform: {
    "^.+\\.[tj]sx?$": "babel-jest",
  },
};
=====================================================================
import React from "react";

const MyComponent: React.FC = () => {
  return <div>Hello, Jest!</div>;
};

export default MyComponent;

=====================================================================
import React from "react";
import { render, screen } from "@testing-library/react";
import MyComponent from "./MyComponent";

describe("MyComponent", () => {
  it("renders correctly", () => {
    render(<MyComponent />);
    expect(screen.getByText("Hello, Jest!")).toBeInTheDocument();
  });
});

================================================================================

npm install --save @nx/react react react-dom
npm install --save-dev @babel/core babel-jest @babel/preset-env @babel/preset-react @babel/preset-typescript jest ts-jest typescript

npm install --save-dev babel-jest @babel/core @babel/preset-env @babel/preset-react
npm install --save-dev @babel/preset-typescript
========================================================

import React from 'react';
import { render, fireEvent } from '@testing-library/react';
import { CLMSelect } from './CLMSelect';

describe('CLMSelect Component', () => {
  it('should render the options and call handleChange on selection', () => {
    // Manual mock function
    const mockHandleChange = (fieldName: string, value: any) => {
      console.log(`handleChange called with fieldName: ${fieldName}, value: ${value}`);
    };

    const mockConfig = {
      fieldName: 'selectField',
      fieldLabel: 'Select Option',
      fieldDescription: 'Choose an option',
      values: ['Option 1', 'Option 2', 'Option 3'],
    };

    const { getByLabelText, getByRole } = render(
      <CLMSelect
        componentConfig={mockConfig}
        section="test-section"
        handleChange={mockHandleChange}
        value="Option 1"
        readOnly={false}
      />
    );

    // Check if options are rendered
    expect(getByRole('option', { name: 'Option 1' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 2' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 3' })).toBeInTheDocument();

    // Simulate user selecting a new option
    fireEvent.change(getByLabelText('Select Option'), { target: { value: 'Option 2' } });

    // Output will be visible in the console
  });
});

===========================================================================
import React from 'react';
import { render, fireEvent } from '@testing-library/react';
import { CLMSelect } from './CLMSelect';

describe('CLMSelect Component', () => {
  it('should render the options and call handleChange on selection', () => {
    const mockHandleChange = jest.fn();

    const mockConfig = {
      fieldName: 'selectField',
      fieldLabel: 'Select Option',
      fieldDescription: 'Choose an option',
      values: ['Option 1', 'Option 2', 'Option 3'],
    };

    const { getByLabelText, getByRole } = render(
      <CLMSelect
        componentConfig={mockConfig}
        section="test-section"
        handleChange={mockHandleChange}
        value="Option 1"
        readOnly={false}
      />
    );

    // Check if options are rendered
    expect(getByRole('option', { name: 'Option 1' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 2' })).toBeInTheDocument();
    expect(getByRole('option', { name: 'Option 3' })).toBeInTheDocument();

    // Simulate user selecting a new option
    fireEvent.change(getByLabelText('Select Option'), { target: { value: 'Option 2' } });

    // Check if handleChange was called
    expect(mockHandleChange).toHaveBeenCalledWith('selectField', 'Option 2');
  });
});

=======================================================================================
{
  "name": "<your-project-name>",
  "targets": {
    "test": {
      "executor": "@nrwl/jest:jest",
      "options": {
        "jestConfig": "apps/<your-project-name>/jest.config.ts",
        "passWithNoTests": true
      },
      "outputs": ["coverage/apps/<your-project-name>"]
    }
  }
}

==========================================
const nxPreset = require('@nx/jest/preset').default;

module.exports = { ...nxPreset };

===============================================================

import { getJestProjects } from '@nx/jest';

export default {
  displayName: '<your-project-name>',
  preset: '../../jest.preset.js',
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
  globals: {},
  transform: {
    '^.+\\.[tj]sx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],
  coverageDirectory: '../../coverage/apps/<your-project-name>',
  testEnvironment: 'jsdom', // Use 'node' if not React-based
};

===============================================================


===============================================================
{
  "projects": {
    "clm-ui-fcrm": {
      "root": "apps/clm-ui-fcrm",
      "sourceRoot": "apps/clm-ui-fcrm/src",
      "projectType": "application",
      "targets": {
        "test": {
          "executor": "@nrwl/jest:jest",
          "outputs": ["coverage/apps/clm-ui-fcrm"],
          "options": {
            "jestConfig": "apps/clm-ui-fcrm/jest.config.ts",
            "passWithNoTests": true
          }
        }
      }
    }
  }
}

=========================================================================
import { Config } from '@jest/types';

// Sync object
const config: Config.InitialOptions = {
  setupFilesAfterEnv: ['./jest.setup.ts'], // Reference the setup file
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.tsx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
};

export default config;
=======================

import React from "react";
import { render, screen } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with the correct path to your component

// Default props for the test
const defaultProps = {
  componentConfig: {
    fieldName: "testDate",
    fieldLabel: "Test Date",
    description: "Select a date",
  },
  section: "Test Section",
  handleChange: jest.fn(),
  value: "2025-01-01",
  errorMessage: "",
  readOnly: false,
};

describe("CLMDate Component", () => {
  it("renders the label and input field", () => {
    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Assert: Check if the label is displayed
    expect(screen.getByText("Test Date")).toBeInTheDocument();

    // Assert: Check if the input field with the correct value is rendered
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeInTheDocument();
    expect(input).toHaveAttribute("type", "date");
  });
});




import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import CLMDate from './CLMDate'; // Adjust the import path based on your project structure

jest.mock('@barclays/blueprint-react', () => ({
  __esModule: true,  // This line indicates that the module is an ES module
  ...jest.requireActual('@barclays/blueprint-react'),
  Icon: () => <span>MockIcon</span>,  // Mock the Icon component
}));

const visibilityRule = { linkedFieldName: 'someField', linkedFieldValue: true };

const componentConfig = {
  fieldName: 'date',
  fieldLabel: 'Date',
  componentType: 'input',
  description: 'Select a date',
  values: ['2025-01-16'],
  isVisible: visibilityRule,
  isEditable: true,
  validation: 'required'
};

test('renders CLMDate component', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  const inputElement = screen.getByLabelText('Date');
  expect(inputElement).toBeInTheDocument();
});

test('calls handleChange on input change', () => {
  const handleChange = jest.fn();
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={handleChange} readOnly={false} />);
  const inputElement = screen.getByLabelText('Date');
  fireEvent.change(inputElement, { target: { value: '2025-01-16' } });
  expect(handleChange).toHaveBeenCalledWith('date', '2025-01-16');
});

test('displays error message', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} errorMessage="Invalid date" />);
  const errorElement = screen.getByText('Invalid date');
  expect(errorElement).toBeInTheDocument();
});

test('renders component as editable or read-only based on isEditable property', () => {
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  const editableInputElement = screen.getByLabelText('Date');
  expect(editableInputElement).not.toBeDisabled();

  const readOnlyConfig = { ...componentConfig, isEditable: false };
  render(<CLMDate componentConfig={readOnlyConfig} value="" handleChange={() => {}} readOnly={true} />);
  const readOnlyInputElement = screen.getByLabelText('Date');
  expect(readOnlyInputElement).toBeDisabled();
});

=============================================================================
jest.mock('@barclays/blueprint-react', () => {
  const originalModule = jest.requireActual('@barclays/blueprint-react');
  return {
    ...originalModule,
    Icon: ({ icon }) => <span data-testid={`icon-${icon}`}>{icon}</span>, // Mock icon rendering
  };
});

===========================================================================
{
  "targets": {
    "test": {
      "executor": "@nrwl/jest:jest",
      "options": {
        "jestConfig": "apps/your-app/jest.config.ts",
        "passWithNoTests": true
      },
      "outputs": ["coverage/apps/your-app"]
    }
  }
}
==================================================================
nx generate @nrwl/jest:configuration your-app-or-lib-name

==================================================================
import { getJestProjects } from '@nrwl/jest';

export default {
  projects: getJestProjects(),
};
===================================================================
/* jest.config.ts */
export default {
  displayName: 'your-app',
  preset: '../../jest.preset.js',
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.[tj]sx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx'],
  coverageDirectory: '../../coverage/apps/your-app',
  setupFilesAfterEnv: ['<rootDir>/src/test-setup.ts'],
};
==================================================================
import '@testing-library/jest-dom';

==================================================================
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with your actual file path
import { ICLMDate } from "./CLMDate.types"; // Replace with your actual interface path

describe("CLMDate Component", () => {
  const mockHandleChange = jest.fn();

  const defaultProps: ICLMDate = {
    componentConfig: {
      fieldName: "testDate",
      fieldLabel: "Test Date",
      description: "Select a date",
    },
    handleChange: mockHandleChange,
    value: "2025-01-01",
    errorMessage: "",
    readOnly: false,
  };

  it("renders the component correctly", () => {
    render(<CLMDate {...defaultProps} />);

    // Check if label is rendered
    expect(screen.getByText("Test Date")).toBeInTheDocument();
    // Check if description is rendered
    expect(screen.getByText("Select a date")).toBeInTheDocument();
    // Check if input is rendered
    const input = screen.getByRole("textbox");
    expect(input).toBeInTheDocument();
    expect(input).toHaveValue("2025-01-01");
  });

  it("calls handleChange when input value changes", () => {
    render(<CLMDate {...defaultProps} />);

    const input = screen.getByRole("textbox");
    fireEvent.change(input, { target: { value: "2025-02-01" } });

    expect(mockHandleChange).toHaveBeenCalledTimes(1);
    expect(mockHandleChange).toHaveBeenCalledWith("testDate", "2025-02-01");
  });

  it("displays an error message if provided", () => {
    render(
      <CLMDate
        {...defaultProps}
        errorMessage="This field is required"
      />
    );

    // Check if the error message is displayed
    expect(screen.getByText("This field is required")).toBeInTheDocument();
  });

  it("disables the input when readOnly is true", () => {
    render(
      <CLMDate
        {...defaultProps}
        readOnly={true}
      />
    );

    const input = screen.getByRole("textbox");
    expect(input).toBeDisabled();
  });

  it("renders the calendar icon", () => {
    render(<CLMDate {...defaultProps} />);

    const calendarIcon = screen.getByLabelText("calendar");
    expect(calendarIcon).toBeInTheDocument();
  });

  it("renders without crashing when section prop is provided", () => {
    render(<CLMDate {...defaultProps} section="Test Section" />);

    // Check if component renders properly with the section prop
    expect(screen.getByText("Test Date")).toBeInTheDocument();
  });
});
=================================================================================================
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import { CLMDate } from "./CLMDate"; // Replace with the correct file path
import { ICLMdate } from "./CLMDate.types"; // Replace with the correct file path

const defaultProps: ICLMdate = {
  componentConfig: {
    fieldName: "testDate",
    fieldLabel: "Test Date",
    description: "Select a date",
  },
  section: "General",
  handleChange: jest.fn(),
  value: "2025-01-01",
  errorMessage: "",
  readOnly: false,
};

describe("CLMDate Component", () => {
  it("renders the component with label, description, and input field", () => {
    render(<CLMDate {...defaultProps} />);

    // Check the label
    expect(screen.getByText("Test Date")).toBeInTheDocument();

    // Check the description
    expect(screen.getByText("Select a date")).toBeInTheDocument();

    // Check the input field
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeInTheDocument();
    expect(input).toHaveAttribute("type", "date");
  });

  it("calls handleChange when the input value changes", () => {
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const input = screen.getByDisplayValue("2025-01-01");

    // Simulate changing the input value
    fireEvent.change(input, { target: { value: "2025-02-01" } });

    // Check if handleChange was called with the correct arguments
    expect(defaultProps.handleChange).toHaveBeenCalledWith(
      "testDate",
      "2025-02-01"
    );
  });

  it("displays an error message when errorMessage prop is provided", () => {
    const propsWithError = {
      ...defaultProps,
      errorMessage: "Invalid date",
    };

    render(<CLMDate {...propsWithError} />);

    // Check if the error message is displayed
    expect(screen.getByText("Invalid date")).toBeInTheDocument();
  });

  it("renders a disabled input when readOnly is true", () => {
    const readOnlyProps = {
      ...defaultProps,
      readOnly: true,
    };

    render(<CLMDate {...readOnlyProps} />);

    // Check if the input is disabled
    const input = screen.getByDisplayValue("2025-01-01");
    expect(input).toBeDisabled();
  });
});
===========================================================================================
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import { CLMDate } from './CLMDate';
import { ICLMdate } from './CLMDate.types';

describe('CLMDate Component', () => {
  it('should render the CLMDate component correctly', () => {
    // Mock handleChange function
    const mockHandleChange = jest.fn();

    // Default props for the component
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: mockHandleChange,
      value: '2024-01-01',
      errorMessage: '',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find elements in the component
    const inputElement = screen.getByRole('textbox');
    const labelElement = screen.getByText('Test Label');
    const descriptionElement = screen.getByText('Test Description');

    // Assertions: Input field, label, and description should be present
    expect(inputElement).toBeInTheDocument();
    expect(labelElement).toBeInTheDocument();
    expect(descriptionElement).toBeInTheDocument();

    // Assert input attributes
    expect(inputElement).toHaveAttribute('type', 'date');
    expect(inputElement).toHaveAttribute('value', '2024-01-01');
    expect(inputElement).not.toBeDisabled();
  });

  it('should call handleChange when input value changes', () => {
    // Mock handleChange function
    const mockHandleChange = jest.fn();

    // Default props
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: mockHandleChange,
      value: '2024-01-01',
      errorMessage: '',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const inputElement = screen.getByRole('textbox');

    // Simulate a change event
    fireEvent.change(inputElement, { target: { value: '2024-02-01' } });

    // Assert handleChange was called with correct arguments
    expect(mockHandleChange).toHaveBeenCalledWith('testField', '2024-02-01');
  });

  it('should render an error message if provided', () => {
    // Default props with an error message
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: jest.fn(),
      value: '2024-01-01',
      errorMessage: 'Invalid date',
      readOnly: false,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the error message
    const errorElement = screen.getByText('Invalid date');

    // Assert the error message is rendered
    expect(errorElement).toBeInTheDocument();
  });

  it('should disable the input field if readOnly is true', () => {
    // Default props with readOnly set to true
    const defaultProps: ICLMdate = {
      componentConfig: {
        fieldName: 'testField',
        fieldLabel: 'Test Label',
        description: 'Test Description',
      },
      handleChange: jest.fn(),
      value: '2024-01-01',
      errorMessage: '',
      readOnly: true,
    };

    // Render the component
    render(<CLMDate {...defaultProps} />);

    // Find the input element
    const inputElement = screen.getByRole('textbox');

    // Assert the input field is disabled
    expect(inputElement).toBeDisabled();
  });
})
=================================================================================
test('renders CLMDate component', () => {
  const componentConfig = { fieldName: 'date', fieldLabel: 'Date', description: 'Select a date' };
  render(<CLMDate componentConfig={componentConfig} value="" handleChange={() => {}} readOnly={false} />);
  
  const inputElement = screen.getByLabelText('Date');
  expect(inputElement).toBeInTheDocument();
});



