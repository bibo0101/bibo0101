import { renderHook } from '@testing-library/react';
import { ReactNode } from 'react';
import { RiskScoreProvider } from '../providers/RiskScoreProvider'; // Adjust to your actual path
import { useRiskScoreProvider } from './useRiskScoreProvider'; // Adjust to your actual path

describe('useRiskScoreProvider', () => {
  it('should throw an error if used outside RiskScoreProvider', () => {
    const { result } = renderHook(() => useRiskScoreProvider());

    expect(result.error).toBeDefined();
    expect(result.error?.message).toBe('useRiskScoreProvider must be used within a RiskScoreProvider');
  });

  it('should return the correct context value when used within a RiskScoreProvider', () => {
    const mockRiskScore = { score: 85 };

    // Properly type the wrapper component
    const wrapper = ({ children }: { children: ReactNode }) => (
      <RiskScoreProvider>{children}</RiskScoreProvider>
    );

    const { result } = renderHook(() => useRiskScoreProvider(), { wrapper });

    // Check if the context value is returned correctly
    expect(result.current).toEqual(mockRiskScore);
  });
});
===========================================================
import { renderHook } from '@testing-library/react';
import { useRiskScoreProvider } from './useRiskScoreProvider';
import { RiskScoreProviderContext } from '../providers/RiskScoreProvider';
import { ReactNode } from 'react';
==========
const RiskScoreProvider = ({ children }: { children: ReactNode }) => {
  const riskScoreContextValue = { score: 85 }; // Mocked context value
  return (
    <RiskScoreProviderContext.Provider value={riskScoreContextValue}>
      {children}
    </RiskScoreProviderContext.Provider>
  );
};

describe('useRiskScoreProvider', () => {
  it('should throw an error if used outside RiskScoreProvider', () => {
    expect(() => {
      renderHook(() => useRiskScoreProvider());
    }).toThrow('useRiskScoreProvider must be used within a RiskScoreProvider');
  });

  it('should return the correct context value when used within a RiskScoreProvider', () => {
    const { result } = renderHook(() => useRiskScoreProvider(), {
      wrapper: RiskScoreProvider, // Wrap with the provider
    });

    expect(result.current).toEqual({ score: 85 }); // Ensure correct data is returned
  });
});
====================================================
import { renderHook } from '@testing-library/react';
import { useApiProvider } from './useApiProvider'; // Adjust the import based on your file structure
import { ApiProviderContext } from '../providers/ApiProvider'; // Adjust the import based on your file structure
import { ReactNode } from 'react';

const ApiProvider = ({ children }: { children: ReactNode }) => {
  const apiContextValue = { someApiData: 'test' };
  return (
    <ApiProviderContext.Provider value={apiContextValue}>
      {children}
    </ApiProviderContext.Provider>
  );
};

describe('useApiProvider', () => {
  it('should throw an error if used outside ApiProvider', () => {
    const { result } = renderHook(() => useApiProvider());

    expect(result.error?.message).toBe('useApiProvider must be used within an ApiProvider');
  });

  it('should return the correct context value when used within an ApiProvider', () => {
    const { result } = renderHook(() => useApiProvider(), {
      wrapper: ApiProvider,
    });

    expect(result.current).toEqual({ someApiData: 'test' });
  });
});=========================================
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { Provider } from 'react-redux';
import configureStore from 'redux-mock-store';
import SelectListener from './SelectListener'; // Adjust the import based on your file structure

const mockStore = configureStore([]);

describe('SelectListener Component', () => {
  let store;

  beforeEach(() => {
    store = mockStore({
      // Mock your Redux state here
      // Example: fcrmEntryField: { /* your mock data */ },
      // invalidFields: { /* your mock data */ },
    });
  });

  test('renders without crashing', () => {
    render(
      <Provider store={store}>
        <SelectListener fieldName="testField" section="testSection" picklistType="testType" />
      </Provider>
    );

    // Check if the component renders correctly
    expect(screen.getByText(/some text/i)).toBeInTheDocument(); // Adjust based on your component
  });

  test('initializes with correct data', () => {
    // Set up your mock state to include initial data
    store = mockStore({
      fcrmEntryField: {
        testField: 'initialValue',
      },
      // other state slices
    });

    render(
      <Provider store={store}>
        <SelectListener fieldName="testField" section="testSection" picklistType="testType" />
      </Provider>
    );

    // Check if the initial data is set correctly
    expect(screen.getByDisplayValue('initialValue')).toBeInTheDocument(); // Adjust based on your component
  });

  test('handles errors correctly', () => {
    // Set up your mock state to include error data
    store = mockStore({
      invalidFields: {
        testField: true,
      },
      // other state slices
    });

    render(
      <Provider store={store}>
        <SelectListener fieldName="testField" section="testSection" picklistType="testType" />
      </Provider>
    );

    // Simulate an error
    fireEvent.change(screen.getByRole('combobox'), { target: { value: '' } }); // Adjust based on your component
    expect(screen.getByText(/error message/i)).toBeInTheDocument(); // Adjust based on your component
  });

  // Add more tests as needed
});
===================================
import { render, screen } from '@testing-library/react';
import { vi } from 'vitest';
import { Provider } from 'react-redux';
import { useForm, FormProvider } from 'react-hook-form';
import configureStore from 'redux-mock-store';
import SelectListener from './SelectListener';
import { useSelector, useDispatch } from 'react-redux';

// Mock store setup
const mockStore = configureStore([]);
const mockDispatch = vi.fn();

// Mock Redux hooks
vi.mock('react-redux', () => ({
  useSelector: vi.fn(),
  useDispatch: () => mockDispatch,
}));

// Mock useFormContext from RHF
vi.mock('react-hook-form', () => ({
  ...vi.importActual('react-hook-form'),
  useFormContext: () => ({
    watch: vi.fn(),
    setError: vi.fn(),
    clearErrors: vi.fn(),
    setValue: vi.fn(),
  }),
}));

describe('SelectListener Component', () => {
  let store: any;

  beforeEach(() => {
    store = mockStore({
      fcrmEntryField: { testField: 'existingValue' }, 
      errorPanelState: { invalidFields: [] },
    });
    vi.clearAllMocks();
  });

  const renderComponent = () => {
    const methods = useForm(); // RHF Form Context
    return render(
      <Provider store={store}>
        <FormProvider {...methods}>
          <SelectListener fieldName="testField" section="testSection" picklistType="testType" />
        </FormProvider>
      </Provider>
    );
  };

  test('renders component correctly', () => {
    renderComponent();
    expect(screen.getByTestId('select-listener')).toBeInTheDocument();
  });

  test('sets initial states correctly', () => {
    renderComponent();
    expect(useSelector).toHaveBeenCalled();
  });

  test('updates previousData when fieldData changes', () => {
    renderComponent();
    expect(useSelector).toHaveBeenCalledWith(expect.any(Function));
  });

  test('handles form validation errors', () => {
    (useSelector as vi.Mock).mockReturnValueOnce({
      invalidFields: ['testField'],
    });

    renderComponent();

    expect(mockDispatch).toHaveBeenCalled();
  });
});
========================
import { describe, it, expect, vi, beforeEach } from "vitest";
import { setRiskItems } from "../store/actions"; // Import Redux action
import BooleanListener from "./BooleanListener"; // Import the component
import { render, fireEvent, screen } from "@testing-library/react";
import { Provider } from "react-redux";
import configureStore from "redux-mock-store";

// Mock store setup
const mockStore = configureStore();
const dispatchMock = vi.fn();
const store = mockStore({ riskItems: new Map() });
store.dispatch = dispatchMock;

// Mock RiskProvider
const riskProvider = {
  removeBooleanRisk: vi.fn(),
  updateBooleanRiskItem: vi.fn(),
};

// Mock implementation of parseRiskItems
const parseRiskItems = vi.fn(() => new Map());

beforeEach(() => {
  vi.clearAllMocks();
});

// Mock component props
const props = {
  fieldName: "testField",
  section: "testSection",
};

// Wrap the component in Redux Provider
const renderComponent = () =>
  render(
    <Provider store={store}>
      <BooleanListener {...props} />
    </Provider>
  );

describe("BooleanListener Component", () => {
  it("renders without crashing", () => {
    renderComponent();
    expect(screen.getByText("testSection")).toBeInTheDocument();
  });

  it("calls updateBooleanRiskItem when a boolean value changes", () => {
    renderComponent();
    const updateBooleanRiskItem = vi.fn();
    updateBooleanRiskItem(true);
    expect(updateBooleanRiskItem).toHaveBeenCalledWith(true);
  });

  it("calls removeBooleanRisk with correct arguments", () => {
    renderComponent();
    riskProvider.removeBooleanRisk("testField", true, parseRiskItems());
    expect(riskProvider.removeBooleanRisk).toHaveBeenCalledWith(
      "testField",
      true,
      parseRiskItems()
    );
  });

  it("dispatches setRiskItems when new risk items are updated", () => {
    renderComponent();
    const newRiskItems = {
      newRiskItems: {},
      updatedRiskScore: 10,
    };
    dispatchMock(setRiskItems(newRiskItems));
    expect(dispatchMock).toHaveBeenCalledWith(setRiskItems(newRiskItems));
  });

  it("handles undefined risk items correctly in parseRiskItems", () => {
    const state = { riskItems: undefined };
    store.getState = () => state;
    expect(parseRiskItems()).toEqual(new Map());
  });

  it("does not update if previous data matches", () => {
    renderComponent();
    const previousData = true;
    const updateBooleanRiskItem = vi.fn();
    updateBooleanRiskItem(previousData);
    expect(updateBooleanRiskItem).not.toHaveBeenCalled();
  });
});
===============================
import { describe, it, expect, vi } from "vitest";

// Mocked function implementations
const updatePep = vi.fn();
const updateForeignDomesticPep = vi.fn();
const updateBooleanRiskItem = vi.fn();

// Function to test
function updateBooleanRisk(answer: boolean, booleanRiskType: string) {
  switch (booleanRiskType) {
    case "pep":
      updatePep(answer);
      break;
    case "foreignDomestic":
      updateForeignDomesticPep(answer);
      break;
    case "standard":
      updateBooleanRiskItem(answer);
      break;
    default:
      return;
  }
}

describe("updateBooleanRisk function", () => {
  it("calls updatePep when booleanRiskType is 'pep'", () => {
    updateBooleanRisk(true, "pep");
    expect(updatePep).toHaveBeenCalledWith(true);
  });

  it("calls updateForeignDomesticPep when booleanRiskType is 'foreignDomestic'", () => {
    updateBooleanRisk(false, "foreignDomestic");
    expect(updateForeignDomesticPep).toHaveBeenCalledWith(false);
  });

  it("calls updateBooleanRiskItem when booleanRiskType is 'standard'", () => {
    updateBooleanRisk(true, "standard");
    expect(updateBooleanRiskItem).toHaveBeenCalledWith(true);
  });

  it("does nothing for unknown booleanRiskType", () => {
    updateBooleanRisk(true, "unknownType");
    expect(updatePep).not.toHaveBeenCalled();
    expect(updateForeignDomesticPep).not.toHaveBeenCalled();
    expect(updateBooleanRiskItem).not.toHaveBeenCalled();
  });
});

==============================================Boolean
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import BooleanListener from './BooleanListener'; // Adjust the import path
import { describe, it, expect, vi } from 'vitest';

// Mock Redux store for testing
const mockStore = configureStore({
  reducer: {
    riskItems: () => ({}),
    riskTolerance: () => ({}),
  },
});

// Mock functions using `vi`
vi.mock('src/Fcrm/hooks/useRiskScoreProvider.tsx', () => ({
  useRiskScoreProvider: vi.fn(() => ({
    getBooleanQuestionSubtype: vi.fn(() => 'standard'),
    updateBooleanRisk: vi.fn(),
    updatePepRisk: vi.fn(),
    removeBooleanRisk: vi.fn(),
  })),
}));

vi.mock('src/redux/selectors/generalDatas', () => ({
  getFcrmEntryField: vi.fn(() => ({
    fieldName: 'testField',
    value: 'Yes',
  })),
  getInvalidFieldsErrorPanelState: vi.fn(() => true),
}));

vi.mock('src/redux/slices/validationStatusSlice.ts', () => ({
  changeFieldIsValidIsVisibleUpdate: vi.fn(),
  changeFieldNotValidIsVisibleUpdate: vi.fn(),
  changeFieldVisibilityRemoval: vi.fn(),
  updateFieldValidationStatusNotValidNotVisible: vi.fn(),
}));

// Import the mocked `useRiskScoreProvider`
import { useRiskScoreProvider } from 'src/Fcrm/hooks/useRiskScoreProvider.tsx';

// Test suite
describe('BooleanListener Component', () => {
  it('renders without crashing', () => {
    render(
      <Provider store={mockStore}>
        <BooleanListener fieldName="testField" section="testSection" />
      </Provider>
    );

    expect(screen.getByText('Error: this is a required field')).toBeInTheDocument();
  });

  it('calls updateBooleanRisk when value changes', async () => {
    const { getByLabelText } = render(
      <Provider store={mockStore}>
        <BooleanListener fieldName="testField" section="testSection" />
      </Provider>
    );

    // Simulate field change
    const radioButtonYes = getByLabelText(/Yes/i);
    fireEvent.click(radioButtonYes);

    await waitFor(() => {
      expect(useRiskScoreProvider().updateBooleanRisk).toHaveBeenCalled();
    });
  });

  it('displays error message when field is required and not filled', async () => {
    const { getByText, getByLabelText } = render(
      <Provider store={mockStore}>
        <BooleanListener fieldName="testField" section="testSection" />
      </Provider>
    );

    const radioButtonNo = getByLabelText(/No/i);
    fireEvent.click(radioButtonNo);

    await waitFor(() => {
      expect(getByText('Error: this is a required field')).toBeInTheDocument();
    });
  });

  it('updates the form state when value is updated', async () => {
    const { getByLabelText } = render(
      <Provider store={mockStore}>
        <BooleanListener fieldName="testField" section="testSection" />
      </Provider>
    );

    const radioButtonYes = getByLabelText(/Yes/i);
    fireEvent.click(radioButtonYes);

    await waitFor(() => {
      expect(getByLabelText(/Yes/i)).toBeChecked();
    });
  });

  it('does not call updateBooleanRisk if the value is unchanged', async () => {
    const { getByLabelText } = render(
      <Provider store={mockStore}>
        <BooleanListener fieldName="testField" section="testSection" />
      </Provider>
    );

    // First, simulate clicking "Yes"
    const radioButtonYes = getByLabelText(/Yes/i);
    fireEvent.click(radioButtonYes);

    // Then simulate clicking "No" (should not call `updateBooleanRisk` if logic prevents redundant calls)
    const radioButtonNo = getByLabelText(/No/i);
    fireEvent.click(radioButtonNo);

    await waitFor(() => {
      expect(useRiskScoreProvider().updateBooleanRisk).not.toHaveBeenCalledTimes(2);
    });
  });
});

============================================================
import { render, waitFor } from "@testing-library/react";
import { vi } from "vitest";
import YourComponent from "../YourComponent"; // Adjust the path

describe("YourComponent", () => {
  const clearErrors = vi.fn();
  const setError = vi.fn();
  const removeRiskItem = vi.fn();
  const updateRiskItems = vi.fn();
  const setErrorMessage = vi.fn();
  const dispatch = vi.fn();

  beforeEach(() => {
    // Reset mocks before each test
    vi.clearAllMocks();
  });

  test("should clear errors when showErrors is false or errorMessage is empty", async () => {
    render(
      <YourComponent 
        showErrors={false} 
        errorMessage="" 
        clearErrors={clearErrors} 
        fieldName="testField" 
        setError={setError} 
      />
    );

    await waitFor(() => {
      expect(clearErrors).toHaveBeenCalledWith("testField");
    });
  });

  test("should set error when showErrors is true and errorMessage is not empty", async () => {
    const errorMessage = "This field is required";

    render(
      <YourComponent 
        showErrors={true} 
        errorMessage={errorMessage} 
        clearErrors={clearErrors} 
        fieldName="testField" 
        setError={setError} 
      />
    );

    await waitFor(() => {
      expect(setError).toHaveBeenCalledWith("testField", { type: "custom", message: errorMessage });
    });
  });

  test("should remove risk items when isVisible is false and previousData is defined", async () => {
    const previousData = { option1: 50, option2: 30 };

    render(
      <YourComponent 
        isVisible={false} 
        previousData={previousData} 
        removeRiskItem={removeRiskItem} 
        dispatch={dispatch} 
      />
    );

    await waitFor(() => {
      Object.entries(previousData).forEach(([option, percentage]) => {
        expect(removeRiskItem).toHaveBeenCalledWith(option, percentage);
      });
    });
  });

  test("should update risk items when isVisible is true and previousData is defined", async () => {
    const previousData = { option1: 50, option2: 30 };

    render(
      <YourComponent 
        isVisible={true} 
        previousData={previousData} 
        updateRiskItems={updateRiskItems} 
        dispatch={dispatch} 
      />
    );

    await waitFor(() => {
      Object.entries(previousData).forEach(([option, percentage]) => {
        expect(updateRiskItems).toHaveBeenCalledWith(option, percentage);
      });
    });
  });

  test("should set error message when rhfFieldData is undefined", async () => {
    render(
      <YourComponent 
        rhfFieldData={undefined} 
        setErrorMessage={setErrorMessage} 
      />
    );

    await waitFor(() => {
      expect(setErrorMessage).toHaveBeenCalledWith('Error: this is a required field');
    });
  });
});
==============================
import { getRiskTolerance } from './yourModule'; // Adjust the import based on your file structure
import { store } from './yourStore'; // Adjust the import based on your file structure

describe('getRiskTolerance', () => {
  it('should return risk tolerance from the store', () => {
    const mockState = {
      riskTolerance: { level: 'medium' },
    };
    store.getState = jest.fn().mockReturnValue(mockState); // Mock the store's getState method

    const result = getRiskTolerance();

    expect(result).toEqual(mockState.riskTolerance);
  });
});
================================================
import { removeRiskItem } from './yourModule'; // Adjust the import based on your file structure

describe('removeRiskItem', () => {
  it('should return early if removedItem.option is undefined', () => {
    const removedItem = { option: undefined };
    const result = removeRiskItem(removedItem);
    expect(result).toBeUndefined(); // Adjust based on what the function returns
  });

  it('should return early if riskData is undefined', () => {
    const removedItem = { option: 'someOption' };
    const result = removeRiskItem(removedItem);
    expect(result).toBeUndefined(); // Adjust based on what the function returns
  });

  // Add more tests to cover other scenarios
});
=================================================================
import { getExistingRiskData } from './yourModule'; // Adjust the import based on your file structure
import { getPicklist } from './yourPicklistModule'; // Adjust the import based on your file structure

jest.mock('./yourPicklistModule'); // Mock the module that contains getPicklist

describe('getExistingRiskData', () => {
  it('should return existing risk data with risk categories', () => {
    const mockPicklist = new Map([
      ["Tech", ["High"]],
      ["Finance", ["Low"]],
    ]);
    
    getPicklist.mockReturnValue(mockPicklist); // Mock the return value of getPicklist

    const result = getExistingRiskData();

    expect(result.riskCategories).toEqual(mockPicklist);
  });
});
============================================================================
import { vi } from "vitest";
import { getExistingRiskData, removeRiskItem, updateThresholdData, getRiskTolerance } from "../yourFile";
import { store } from "../store"; // Adjust the import path as needed

// Mock dependencies
const getPicklist = vi.fn(() => new Map([["Tech", ["High"]], ["Finance", ["Low"]]]));
const dispatch = vi.fn();
store.dispatch = dispatch;

describe("Risk Data Functions", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  test("getExistingRiskData should return riskCategories from getPicklist", () => {
    const result = getExistingRiskData();
    expect(result.riskCategories).toEqual(getPicklist());
    expect(getPicklist).toHaveBeenCalled();
  });

  test("removeRiskItem should return early if removedItem.option is undefined", () => {
    expect(removeRiskItem({ option: undefined })).toBeUndefined();
  });

  test("removeRiskItem should return early if riskData is undefined", () => {
    vi.spyOn(riskProvider, "getQuestion").mockReturnValue(undefined);
    expect(removeRiskItem({ option: "Tech" })).toBeUndefined();
  });

  test("removeRiskItem should call updateThresholdData if thresholdUpdateResponse is defined", () => {
    const mockThresholdResponse = { newMultiSelectAnswers: { Tech: ["High"] } };
    vi.spyOn(riskProvider, "getQuestion").mockReturnValue(mockThresholdResponse);
    const updateThresholdDataMock = vi.spyOn(global, "updateThresholdData").mockImplementation(() => {});
    
    removeRiskItem({ option: "Tech" });

    expect(updateThresholdDataMock).toHaveBeenCalledWith(mockThresholdResponse);
  });

  test("updateThresholdData should update store with new risk thresholds", () => {
    const mockThresholdResponse = { newMultiSelectAnswers: { Tech: ["High"], Finance: [] } };
    updateThresholdData(mockThresholdResponse);

    expect(dispatch).toHaveBeenCalledWith({
      type: "updateMultiselectThresholds",
      payload: { newMultiSelectAnswers: { Tech: ["High"] } } // Finance should be removed
    });
  });

  test("getRiskTolerance should return riskTolerance from Redux store", () => {
    vi.spyOn(store, "getState").mockReturnValue({
      riskTolerance: { Tech: "High", Finance: "Low" }
    });

    const result = getRiskTolerance();
    expect(result).toEqual({ Tech: "High", Finance: "Low" });
  });
});
=====================================================

import { getErrorMessage, getChangedData, getPicklist } from "../riskDataUpdater";
import { store } from "../../store";

jest.mock("../../store", () => ({
  store: {
    getState: jest.fn(),
  },
}));

describe("riskDataUpdater", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("getErrorMessage", () => {
    it("should return required field error when map is empty", () => {
      const thresholdData = new Map();
      expect(getErrorMessage(thresholdData)).toBe("Error: this is a required field");
    });

    it("should return error for percentage less than 1", () => {
      const thresholdData = new Map([["Option1", 0]]);
      expect(getErrorMessage(thresholdData)).toBe("Error: percentages cannot be less than 1%");
    });

    it("should return error for percentage greater than 100", () => {
      const thresholdData = new Map([["Option1", 110]]);
      expect(getErrorMessage(thresholdData)).toBe("Error: percentages cannot be greater than 100%");
    });

    it("should return an empty string if all percentages are valid", () => {
      const thresholdData = new Map([["Option1", 50]]);
      expect(getErrorMessage(thresholdData)).toBe("");
    });
  });

  describe("getChangedData", () => {
    it("should detect additions and removals correctly", () => {
      const previousData = new Map([
        ["Option1", 50],
        ["Option2", 20],
      ]);
      const newItems = new Map([
        ["Option1", 50], // unchanged
        ["Option3", 30], // new addition
      ]);

      const result = getChangedData(newItems);
      expect(result.addition).toEqual({ option: "Option3", percentage: 30 });
      expect(result.removal).toEqual({ option: "Option2", percentage: 20 });
    });

    it("should return empty changes when no difference", () => {
      const previousData = new Map([
        ["Option1", 50],
      ]);
      const newItems = new Map([
        ["Option1", 50],
      ]);

      const result = getChangedData(newItems);
      expect(result.addition).toEqual({ option: "", percentage: 0 });
      expect(result.removal).toEqual({ option: "", percentage: 0 });
    });
  });

  describe("getPicklist", () => {
    it("should return country risks if picklistType is 'country'", () => {
      store.getState.mockReturnValue({
        countryRisks: { USA: ["High"], UK: ["Medium"] },
        industryRisks: {},
      });

      const result = getPicklist("country");
      expect(result).toEqual(new Map([
        ["USA", ["High"]],
        ["UK", ["Medium"]],
      ]));
    });

    it("should return industry risks if picklistType is 'industry'", () => {
      store.getState.mockReturnValue({
        countryRisks: {},
        industryRisks: { Tech: ["High"], Finance: ["Low"] },
      });

      const result = getPicklist("industry");
      expect(result).toEqual(new Map([
        ["Tech", ["High"]],
        ["Finance", ["Low"]],
      ]));
    });

    it("should return an empty map when no data is found", () => {
      store.getState.mockReturnValue({
        countryRisks: {},
        industryRisks: {},
      });

      const result = getPicklist("unknown");
      expect(result).toEqual(new Map());
    });
  });
});
============================================================
import { updateRiskItems, removeRiskItem, updateThresholdData, getExistingRiskData, getRiskTolerance } from "../riskDataUpdater";
import { updateMultiselectThresholds } from "../../actions";
import { store } from "../../store"; 

jest.mock("../../store", () => ({
  store: {
    getState: jest.fn(),
    dispatch: jest.fn(),
  },
}));

const mockRiskProvider = {
  getQuestionRiskData: jest.fn(),
  updateThresholdValues: jest.fn(),
  removeThresholdValue: jest.fn(),
};

jest.mock("../../riskProvider", () => mockRiskProvider);

describe("riskDataUpdater", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("updateRiskItems", () => {
    it("should not update when riskData is undefined", () => {
      mockRiskProvider.getQuestionRiskData.mockReturnValue(undefined);
      updateRiskItems({ option: "Test", percentage: 50 });
      expect(mockRiskProvider.updateThresholdValues).not.toHaveBeenCalled();
    });

    it("should not update when percentage is greater than 100", () => {
      mockRiskProvider.getQuestionRiskData.mockReturnValue({});
      updateRiskItems({ option: "Test", percentage: 110 });
      expect(mockRiskProvider.updateThresholdValues).not.toHaveBeenCalled();
    });

    it("should update thresholds correctly", () => {
      const mockRiskData = {};
      const mockThresholdResponse = { updated: true };
      mockRiskProvider.getQuestionRiskData.mockReturnValue(mockRiskData);
      mockRiskProvider.updateThresholdValues.mockReturnValue(mockThresholdResponse);

      updateRiskItems({ option: "Test", percentage: 50 });

      expect(mockRiskProvider.updateThresholdValues).toHaveBeenCalledWith(mockRiskData, expect.anything());
      expect(store.dispatch).toHaveBeenCalledWith(updateMultiselectThresholds(mockThresholdResponse));
    });
  });

  describe("removeRiskItem", () => {
    it("should not remove when riskData is undefined", () => {
      mockRiskProvider.getQuestionRiskData.mockReturnValue(undefined);
      removeRiskItem({ option: "Test", percentage: 50 });
      expect(mockRiskProvider.removeThresholdValue).not.toHaveBeenCalled();
    });

    it("should remove threshold value correctly", () => {
      const mockRiskData = {};
      const mockThresholdResponse = { updated: true };
      mockRiskProvider.getQuestionRiskData.mockReturnValue(mockRiskData);
      mockRiskProvider.removeThresholdValue.mockReturnValue(mockThresholdResponse);

      removeRiskItem({ option: "Test", percentage: 50 });

      expect(mockRiskProvider.removeThresholdValue).toHaveBeenCalledWith(mockRiskData, "Test", expect.anything());
      expect(store.dispatch).toHaveBeenCalledWith(updateMultiselectThresholds(mockThresholdResponse));
    });
  });

  describe("getExistingRiskData", () => {
    it("should return existing risk data", () => {
      const mockExistingData = { riskCategories: ["Category1"] };
      store.getState.mockReturnValue(mockExistingData);

      const result = getExistingRiskData();
      expect(result.riskCategories).toEqual(["Category1"]);
    });
  });

  describe("updateThresholdData", () => {
    it("should dispatch updated threshold data", () => {
      const mockResponse = { updatedData: "New Data" };
      updateThresholdData(mockResponse);
      expect(store.dispatch).toHaveBeenCalledWith(updateMultiselectThresholds(mockResponse));
    });
  });

  describe("getRiskTolerance", () => {
    it("should return risk tolerance from state", () => {
      store.getState.mockReturnValue({ riskTolerance: 80 });

      const result = getRiskTolerance();
      expect(result).toBe(80);
    });
  });
});
===================================================
import { render, screen } from "@testing-library/react";
import { describe, it, expect, vi } from "vitest";
import ThresholdListener from "path-to/ThresholdListener";
import { useStore } from "react-redux";

vi.mock("react-redux", () => ({
  useStore: vi.fn(),
}));

describe("ThresholdListener Component", () => {
  let mockDispatch: vi.Mock;

  beforeEach(() => {
    mockDispatch = vi.fn();
    (useStore as vi.Mock).mockReturnValue({ dispatch: mockDispatch });
  });

  it("should update previousData when fieldData changes", () => {
    const { rerender } = render(<ThresholdListener fieldData={{ test: 1 }} />);
    
    expect(mockDispatch).not.toHaveBeenCalled();
    
    rerender(<ThresholdListener fieldData={{ test: 2 }} />);
    
    // Ensure previousData updates (mock setPreviousData if needed)
  });

  it("should clear errors when showErrors is false", () => {
    const clearErrors = vi.fn();
    
    render(<ThresholdListener showErrors={false} clearErrors={clearErrors} fieldName="testField" />);
    
    expect(clearErrors).toHaveBeenCalledWith("testField");
  });

  it("should call setError when showErrors is true and errorMessage exists", () => {
    const setError = vi.fn();
    
    render(<ThresholdListener showErrors={true} errorMessage="Error!" setError={setError} fieldName="testField" />);
    
    expect(setError).toHaveBeenCalledWith("testField", { type: "custom", message: "Error!" });
  });

  it("should remove risk items and update visibility when not visible", () => {
    const removeRiskItem = vi.fn();
    
    render(<ThresholdListener isVisible={false} previousData={new Map([["option1", 50]])} removeRiskItem={removeRiskItem} />);
    
    expect(removeRiskItem).toHaveBeenCalledWith("option1", 50);
    expect(mockDispatch).toHaveBeenCalledWith(expect.objectContaining({ type: "changeFieldVisibilityRemoval" }));
  });

  it("should update risk items and setValue when visible", () => {
    const updateRiskItems = vi.fn();
    const setValue = vi.fn();

    render(<ThresholdListener isVisible={true} previousData={new Map([["option1", 50]])} updateRiskItems={updateRiskItems} setValue={setValue} fieldName="testField" />);
    
    expect(updateRiskItems).toHaveBeenCalledWith("option1", 50);
    expect(setValue).toHaveBeenCalledWith("testField", expect.any(Map));
  });
});

