// Calculate viewBox to avoid cutting nodes
    const padding = 100; // Add padding around the chart
    const viewBoxWidth = maxNodeX - minNodeX + padding * 2;
    const viewBoxHeight = maxNodeY - minNodeY + padding * 2;
    const viewBoxX = minNodeX - padding;
    const viewBoxY = minNodeY - padding;

    const svg = d3.select(svgRef.current);

    // Update the SVG element
    svg
      .attr("viewBox", `${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}`)
      .attr("width", containerWidth)
      .attr("height", containerHeight);

    const g = svg.append("g");


==============
import React, { useEffect, useRef } from "react";
import * as d3 from "d3";

const Flowchart = ({ data }: { data: any[] }) => {
  const svgRef = useRef<SVGSVGElement | null>(null);

  useEffect(() => {
    if (!data || !svgRef.current) return;

    // Create root and layout
    const root = d3
      .stratify()
      .id((d: any) => d.id)
      .parentId((d: any) => d.parentId)(data);

    const treeLayout = d3.tree().nodeSize([150, 200]); // Adjust spacing
    treeLayout(root);

    const nodes = root.descendants(); // Get all nodes
    const links = root.links(); // Get all links

    // Adjust SVG dimensions
    updateSvgSize(nodes, svgRef.current);

    // Render nodes and links...
    const svg = d3.select(svgRef.current);
    const g = svg.append("g");

    // Draw links
    g.selectAll(".link")
      .data(links)
      .enter()
      .append("path")
      .attr("class", "link")
      .attr("d", d3.linkHorizontal()
        .x((d: any) => d.x)
        .y((d: any) => d.y)
      )
      .attr("fill", "none")
      .attr("stroke", "#ccc");

    // Draw nodes
    const nodeGroup = g.selectAll(".node")
      .data(nodes)
      .enter()
      .append("g")
      .attr("class", "node")
      .attr("transform", (d: any) => `translate(${d.x},${d.y})`);

    nodeGroup.append("rect")
      .attr("width", 120)
      .attr("height", 50)
      .attr("x", -60)
      .attr("y", -25)
      .attr("rx", 10)
      .attr("ry", 10)
      .attr("fill", "#007bff");

    nodeGroup.append("text")
      .attr("text-anchor", "middle")
      .attr("dy", ".35em")
      .text((d: any) => d.data.name);
  }, [data]);

  return <svg ref={svgRef}></svg>;
};

const updateSvgSize = (nodes: d3.HierarchyPointNode<any>[], svgElement: SVGSVGElement) => {
  const xExtent = d3.extent(nodes, (d) => d.x)!;
  const yExtent = d3.extent(nodes, (d) => d.y)!;

  const padding = 100;
  const newWidth = xExtent[1]! - xExtent[0]! + padding * 2;
  const newHeight = yExtent[1]! - yExtent[0]! + padding * 2;

  const svg = d3.select(svgElement);
  svg
    .attr("width", Math.max(newWidth, window.innerWidth))
    .attr("height", Math.max(newHeight, window.innerHeight))
    .attr(
      "viewBox",
      `${xExtent[0]! - padding} ${yExtent[0]! - padding} ${newWidth} ${newHeight}`
    );
};

export default Flowchart;
================================================================================================================



// Update SVG size dynamically based on node positions
const updateSvgSize = (nodes: any[]) => {
  const xExtent = d3.extent(nodes, (d: any) => d.x); // Get min and max x
  const yExtent = d3.extent(nodes, (d: any) => d.y); // Get min and max y
  
  const padding = 50; // Add some extra padding
  const newWidth = (xExtent[1] - xExtent[0]) + padding * 2;
  const newHeight = (yExtent[1] - yExtent[0]) + padding * 2;

  d3.select('svg')
    .attr('width', Math.max(newWidth, window.innerWidth)) // Ensure at least full window size
    .attr('height', Math.max(newHeight, window.innerHeight));
};

// Call this after layout
updateSvgSize(nodes);







// Add cross-links
const crossLinks = data
  .filter((d) => d.crossLink)
  .map((d) => ({
    source: treeData.descendants().find((node) => node.data.id === d.id),
    target: treeData.descendants().find((node) => node.data.id === d.crossLink)
  }));

// Draw cross-links
svg.selectAll(".cross-link")
  .data(crossLinks)
  .enter()
  .append("path")
  .attr("class", "cross-link")
  .attr("d", (d: any) =>
    d3.linkHorizontal()({
      source: [d.source.y, d.source.x],
      target: [d.target.y, d.target.x]
    })
  )
  .style("stroke", "red")
  .style("stroke-dasharray", "4 2")
  .style("fill", "none");
================================================================ for stratify method
function elbow(d: any) {
  return `M${d.source.y},${d.source.x} H${d.target.y} V${d.target.x}`;
}
----------------------------------------------------------------Add separate cross link path
svg.selectAll(".cross-link")
  .data(flatData.filter((d) => d.crossLink)) // Filter nodes with crossLinks
  .enter()
  .append("path")
  .attr("class", "cross-link")
  .attr("d", (d) => {
    const sourceNode = treeData.descendants().find((n) => n.data.id === d.id);
    const targetNode = treeData.descendants().find((n) => n.data.id === d.crossLink);
    if (sourceNode && targetNode) {
      return `M${sourceNode.y},${sourceNode.x} C${(sourceNode.y + targetNode.y) / 2},${sourceNode.x} ${(sourceNode.y + targetNode.y) / 2},${targetNode.x} ${targetNode.y},${targetNode.x}`;
    }
    return null;
  })
  .style("fill", "none")
  .style("stroke", "red") // Optional: color cross-links differently
  .style("stroke-width", 2)
  .style("stroke-dasharray", "4 2"); // Optional: make dashed
